[
  {
    "objectID": "DevBlog/posts/post-with-code/index.html",
    "href": "DevBlog/posts/post-with-code/index.html",
    "title": "OUTBREAK SIMULATOR",
    "section": "",
    "text": "OH GOD… THE ZOMBIES\nVideo"
  },
  {
    "objectID": "DevBlog/posts/falconGUI/index.html",
    "href": "DevBlog/posts/falconGUI/index.html",
    "title": "OutbreakSim GUI",
    "section": "",
    "text": "On Getting a GUI Program to Submit Jobs on a Supercomputer\nAfter making the program work on the command line and accept arguments, it was time to create a GUI interface to let people more easily interact with the program and run jobs. The actual GUI program runs in a singularity container with wxLua, a Lua binding to wxWidgets.\n\nThe program has a number of text inputs and will spit out a slurm file like this:\n#!/bin/bash\n\n#SBATCH -p tiny -a 1-5\n\ncd $SLURM_SUBMIT_DIR\n\n./OutbreakSimulator --params id=0.5 -opost -Run1-$SLURM_ARRAY_TASK_ID -startat ATL --stop 5 -airports \nAnd then I ran into a problem, how do I submit this file to the job system while running in a container? The container doesn’t have access to the host system’s environment, this is after all kind of the point. So how do we get access to the job system from here?\nOne of the interesting features of singularity is that it automatically binds the user’s home directory to the container’s environment. So the container can read file from the user’s home directory, and the container can write files there as well. This opens up a very nice way to communicate between the two environments.\nThe basic way the communication works is as follows:\n\nThe user open the GUI program using the provided shell script\nThe shell script also opens a seperate program that runs in the background on the host system\nWhen the GUI program needs to do something on the host, it writes to a file somehwere which we’ll call input\nWhen the GUI program is done writing, it creates a file called inputset\nThe program on the host waits for the inputset file to be created, and when it is, will run the contents of input as Lua code using the Lua function dofile\nAfter the code is ran on the host, the program will delete the inputset file to mark that it is ready for new input\n\nIn this way, the GUI program can specify any artbitrary code to run on the host. The only thing it does with this power is access the sbatch and squeue command to execute and read the status of the job queue respectively.\nIn the end, it was quite a simple program to get working. The GUI library is relatively easy to use, and the communication between the host and container wasn’t hard to implement; however, it was a real noodle scratcher to get some pieces of this working."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html",
    "title": "TwinStick Data Summary",
    "section": "",
    "text": "The purpose of this document is to consistently summarize the data from Project TwinStick, allowing us to more consistently test the evolutionary model and gameplay during development."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#data",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#data",
    "title": "TwinStick Data Summary",
    "section": "Data",
    "text": "Data\nIn this section, we ingest the data from whatever runs are relevant to the analysis. The data are written from the project in .csv files. The following code reads all .csv files from the working directory. It creates new variables for the source file name (file) and the number of offspring produced by each individual (offspring_count). It then appends all the data files into a single data frame called allfiles.\n\n\nCode\nlibrary(tidyverse)\nlibrary(pheatmap)\n\n\nfiles &lt;- list.files(pattern = \"*.csv\", full.names = TRUE)\n\nallfiles = data.frame()\nfor(csv in files){\n  Twin3 &lt;- read.csv(csv, as.is=T, header=T)\n  Twin3['file'] = csv\n\n\nTwin3&lt;-Twin3%&gt;%\n  mutate(Unique.Slime.ID = paste(Wave.Number, \".\", Slime.ID))%&gt;%\n  mutate(Unique.Parent.One = paste(Wave.Number-1, \".\", Parent.One))%&gt;%\n  mutate(Unique.Parent.Two = paste(Wave.Number-1, \".\", Parent.Two))\n\n\ndf_parents &lt;- Twin3 %&gt;%\n  select(Unique.Parent.One, Unique.Parent.Two) %&gt;%\n  pivot_longer(cols = everything(), names_to = \"parent_type\", values_to = \"parent_id\")\n\n# Count the number of offspring for each parent\noffspring_counts &lt;- df_parents %&gt;%\n  group_by(parent_id) %&gt;%\n  summarise(offspring_count = n(), .groups = \"drop\")\n\noffspring_counts &lt;- offspring_counts%&gt;%\n  filter(parent_id != \"-1 . N/A\")\n\n\noffspring_counts&lt;- rename(offspring_counts, Unique.Slime.ID = parent_id)\n\n\n\nTwin3 &lt;- Twin3 %&gt;%\n  left_join(offspring_counts, by = \"Unique.Slime.ID\")%&gt;%\n  replace_na(list(offspring_count = 0))\n\nallfiles&lt;-rbind(allfiles,Twin3)\n\n}\n\nallfiles&lt;-allfiles%&gt;%\n  select(-X)%&gt;%\n  mutate(Lightning.Resist.Trait = case_when(\n    Main.Type == \"Lightning\" & Secondary.Type == \"Lightning\" ~ 0.5 + Secondary.Resistance.Trait,\n    Main.Type == \"Lightning\" & Secondary.Type != \"Lightning\" ~ 0.5 ,\n    Main.Type != \"Lightning\" & Secondary.Type == \"Lightning\" ~ Secondary.Resistance.Trait,\n    Main.Type != \"Lightning\" & Secondary.Type != \"Lightning\" ~ 0,\n    TRUE ~ 0\n  ))\n\n\nTraits &lt;- c(\"Lightning.Resist.Trait\", \"Main.Resistance.Trait\", \"Secondary.Resistance.Trait\", \"Speed.Trait\",\n           \"Tower.Attraction.Trait\", \"Slime.Optimal.Distance.Trait\", \"Turn.Rate.Trait\", \n           \"Slime.View.Range.Trait\", \"Tower.View.Range.Trait\")\n\nGenes &lt;- c(\"Main.Resistance.Gene\", \"Secondary.Resistance.Gene\", \"Speed.Gene\",\n           \"Tower.Attraction.Gene\", \"Slime.Optimal.Distance.Gene\", \"Turn.Rate.Gene\", \n           \"Slime.View.Range.Gene\", \"Tower.View.Range.Gene\")\n\nallfiles&lt;-allfiles%&gt;%\n  mutate(Generation=as.factor(Wave.Number))%&gt;%\n  mutate(offspring.count.Fitness = offspring_count) %&gt;%\n   mutate(Actual.Distance.Fitness = (Player.Distance.Fitness/50000) -1)\n\nTraitAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Trait\"), mean,  na.rm = TRUE))\n\nGeneAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Gene\"), list(mean = mean, var = var), na.rm = TRUE, .names = \"{.fn}.{.col}\"))\n\nFitAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Fitness\"), list(mean = mean, var = var), na.rm = TRUE, .names = \"{.fn}.{.col}\"))\n\n\nThe allfiles dataframe contains the following variables (I also show a few columns of the example data):\n\n\nCode\ndata.dictionary &lt;- t(as.data.frame(head(allfiles)))\nknitr::kable(data.dictionary)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\nSlime.ID\n0\n1\n2\n3\n4\n5\n\n\nWave.Number\n0\n0\n0\n0\n0\n0\n\n\nPath.Distance.To.Player\n0\n0\n0\n0\n0\n0\n\n\nPlayer.Distance.Fitness\n878.0573\n942.4612\n1099.4340\n923.3716\n923.5927\n956.4991\n\n\nParent.One\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\n\n\nParent.Two\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\n\n\nMain.Type\nFire\nPlayer\nFire\nBlaster\nBalanced\nFire\n\n\nSecondary.Type\nLightning\nPlayer\nBlaster\nBlaster\nPlayer\nBalanced\n\n\nMain.Resistance.Gene\n2.060887000\n2.872348000\n1.006045000\n-0.008765968\n-0.950339600\n-1.279348000\n\n\nMain.Resistance.Trait\n0.5781593\n0.6267003\n0.5128749\n0.4496236\n0.3923166\n0.3728904\n\n\nSecondary.Resistance.Gene\n0.01938968\n-0.46283390\n2.65991700\n2.17777000\n1.29421200\n2.88058900\n\n\nSecondary.Resistance.Trait\n0.1831496\n0.1657976\n0.3025845\n0.2777685\n0.2356916\n0.3143516\n\n\nSlime.View.Range.Gene\n1.45217100\n-4.52872900\n0.41324340\n-0.08973839\n1.15681100\n1.33135500\n\n\nSlime.View.Range.Trait\n9.846652\n4.656380\n8.887072\n8.415874\n9.577014\n9.736749\n\n\nTower.View.Range.Gene\n0.7422258\n-2.4267900\n-0.1783606\n-1.0232440\n1.5237570\n-1.4051460\n\n\nTower.View.Range.Trait\n22.85026\n15.11252\n20.55417\n18.45575\n24.76398\n17.52282\n\n\nPlayer.View.Range.Gene\n-0.70632820\n-0.01583275\n-0.06684434\n0.40760770\n-0.34967610\n-2.37537300\n\n\nPlayer.View.Range.Trait\n3.356673\n3.681639\n3.656685\n3.894415\n3.521046\n2.688438\n\n\nWall.View.Range.Gene\n0.13138430\n0.20673470\n1.63018500\n4.42545100\n0.04316422\n2.65278900\n\n\nWall.View.Range.Trait\n5.131722\n5.188353\n6.341081\n8.898485\n5.066026\n7.248795\n\n\nSheep.View.Range.Gene\n1.77112100\n0.03020487\n0.63438080\n3.76045600\n-2.25865400\n3.12416400\n\n\nSheep.View.Range.Trait\n6.462865\n5.056430\n5.518585\n8.275494\n3.594677\n7.682169\n\n\nSlime.Attraction.Gene\n-0.97361480\n0.02759038\n-0.08706515\n0.41256310\n1.06375000\n0.37561050\n\n\nSlime.Attraction.Trait\n0.4394477\n0.5017244\n0.4945587\n0.5257624\n0.5660953\n0.5234584\n\n\nTower.Attraction.Gene\n-0.4425031\n0.1369935\n0.7489339\n-0.6538926\n0.1313944\n-0.8749940\n\n\nTower.Attraction.Trait\n-0.9880077\n-0.9861512\n-0.9838803\n-0.9886215\n-0.9861704\n-0.9892301\n\n\nPlayer.Attraction.Gene\n-0.6821441\n-1.6283370\n3.9870850\n4.2225470\n-3.0099490\n1.2839510\n\n\nPlayer.Attraction.Trait\n0.01473093\n-0.10317370\n0.53589990\n0.55654820\n-0.26942490\n0.25475740\n\n\nWall.Attraction.Gene\n0.1195688\n1.1711760\n-0.2865770\n0.7249610\n1.3997780\n-1.4818690\n\n\nWall.Attraction.Trait\n-0.8776227\n-0.8464735\n-0.8881165\n-0.8604172\n-0.8388985\n-0.9145474\n\n\nSheep.Attraction.Gene\n0.8572116\n-1.3909040\n-2.0276770\n-1.3564410\n-0.8138410\n1.9432800\n\n\nSheep.Attraction.Trait\n0.7710594\n0.6575227\n0.6208318\n0.6594602\n0.6892338\n0.8154501\n\n\nSlime.Optimal.Distance.Gene\n0.2664202\n-0.2785142\n-2.2960630\n1.5807830\n3.4963320\n0.9412469\n\n\nSlime.Optimal.Distance.Trait\n0.27595890\n0.21192480\n-0.03699094\n0.41992250\n0.59607800\n0.35193960\n\n\nSpeed.Gene\n2.67080900\n0.76555180\n3.71029500\n0.56656130\n-0.08200173\n-2.95797200\n\n\nSpeed.Trait\n3.594294\n2.798228\n4.074744\n2.722425\n2.485705\n1.628774\n\n\nTurn.Rate.Gene\n-2.0039470\n0.3158437\n0.5855277\n5.9859360\n0.6421707\n1.5284210\n\n\nTurn.Rate.Trait\n0.1190994\n0.1944987\n0.2052795\n0.4991210\n0.2075993\n0.2464020\n\n\nSprint.Duration.Gene\n0.3580502\n-1.4255720\n0.9057481\n-0.9512499\n-2.5994610\n-0.4005764\n\n\nSprint.Duration.Trait\n2.611816\n2.059165\n2.781843\n2.204128\n1.715100\n2.374924\n\n\nSprint.Cooldown.Gene\n0.1790418\n-2.5914650\n-1.9531460\n-0.6929213\n4.2617590\n1.3097360\n\n\nSprint.Cooldown.Trait\n2.7232060\n0.3484487\n0.6210535\n1.6669180\n4.9304920\n3.9373440\n\n\nfile\n./geneWriteFile08_07_2023_12-54-56.csv\n./geneWriteFile08_07_2023_12-54-56.csv\n./geneWriteFile08_07_2023_12-54-56.csv\n./geneWriteFile08_07_2023_12-54-56.csv\n./geneWriteFile08_07_2023_12-54-56.csv\n./geneWriteFile08_07_2023_12-54-56.csv\n\n\nUnique.Slime.ID\n0 . 0\n0 . 1\n0 . 2\n0 . 3\n0 . 4\n0 . 5\n\n\nUnique.Parent.One\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n\n\nUnique.Parent.Two\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n\n\noffspring_count\n3\n1\n4\n4\n0\n0\n\n\nLightning.Resist.Trait\n0.1831496\n0.0000000\n0.0000000\n0.0000000\n0.0000000\n0.0000000\n\n\nGeneration\n0\n0\n0\n0\n0\n0\n\n\noffspring.count.Fitness\n3\n1\n4\n4\n0\n0\n\n\nActual.Distance.Fitness\n-0.9824389\n-0.9811508\n-0.9780113\n-0.9815326\n-0.9815281\n-0.9808700\n\n\n\n\n\nVariables that end in .Gene are the values of the genome for that particular locus. Variables that end in .Trait are the values of the trait for that particular locus."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#experimental-conditions",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#experimental-conditions",
    "title": "TwinStick Data Summary",
    "section": "Experimental Conditions",
    "text": "Experimental Conditions\nUse this section to describe the goal of the data collection and the key conditions that define the test.\nThis test occurred July 21, 2023 and was focused on the new fitness functions implemented by Justin. We are interested in determining whether the fitness functions work correctly.\nThe conditions were a standard “L” shaped set of walls with four lightning towers. The slimes acquire fitness by getting close to the player using a formula of 50,000 / (path distance +1). For replicates 4-6, Justin corrected the math concerning the ~.Resistance.~ genes."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#slime-types",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#slime-types",
    "title": "TwinStick Data Summary",
    "section": "Slime Types",
    "text": "Slime Types\nEach Slime has a Main.Type and a Secondary.Type. These types use the ~.Resistance.~ category to confer resistance to the appropriate damage type. Under certain experimental conditions, we would expect the ~.Type and ~.Resistance.~ genes and traits to evolve in response to the predominant damage type delivered by the player.\nThe following code creates two summary dataframes with the suffix ~Typecounts that count the number of slimes of each ~.Type in each generation for each replicate. It then creates the graphs of ~Type frequency over time.\n\n\nCode\nMainTypecounts &lt;- allfiles %&gt;%\n  group_by(Main.Type, Generation, file) %&gt;%\n  summarise(Main.count = n(), .groups = \"drop\")\n\nSecondaryTypecounts &lt;- allfiles %&gt;%\n  group_by(Secondary.Type, Generation, file) %&gt;%\n  summarise(Secondary.count = n(), .groups = \"drop\")\n\n            \n\nggplot(MainTypecounts, aes(x = Generation, y = Main.count, fill = as.factor(Main.Type))) +\n  geom_col(position = \"stack\") +\n  labs(x = \"Generation\", y = \"Count\", fill = \"Main Slime Type\") +\n  theme_minimal()+\n  facet_wrap(~file, ncol=2)\n\n\n\n\n\nCode\nggplot(SecondaryTypecounts, aes(x = Generation, y = Secondary.count, fill = as.factor(Secondary.Type))) +\n  geom_col(position = \"stack\") +\n  labs(x = \"Generation\", y = \"Count\", fill = \"Secondary Slime Type\") +\n  theme_minimal()+\n  facet_wrap(~file, ncol=2)"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#slime-fitness",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#slime-fitness",
    "title": "TwinStick Data Summary",
    "section": "Slime Fitness",
    "text": "Slime Fitness\nThis section should summarize the behavior of the fitness function. The fitness function calculates a value of 50,000/(distance to player +1). I will also reverse calculate that for visualization.\n\n\nCode\nggplot(allfiles, aes(x=Wave.Number, y= Player.Distance.Fitness))+\n  geom_point(aes(x=Wave.Number, y= Player.Distance.Fitness, color = offspring_count),alpha =0.1)+\n  geom_smooth()+\n  facet_wrap(~file, ncol = 2)+\n  scale_color_continuous(low=\"blue\", high = \"red\")\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nCode\nggplot(data = FitAvg, aes(x = as.numeric(Generation), y = var.offspring.count.Fitness))+\n    geom_point()+\n    geom_smooth(method = \"loess\") +\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nCode\nggplot(allfiles, aes(x = as.factor(Wave.Number), y = Player.Distance.Fitness, fill = Wave.Number)) + \n  geom_violin() +\n  theme(legend.position = \"none\")+\n  facet_wrap(~file, ncol = 2)\n\n\n\n\n\nCode\ntraittemp&lt;-allfiles%&gt;%\n  select(Generation, offspring_count, file, Player.Distance.Fitness)%&gt;%\n  group_by(Generation, file)%&gt;%\n  mutate(scaleST0 = scale(Player.Distance.Fitness, center = TRUE))%&gt;%\n  mutate(scaleST02 = scaleST0*scaleST0)%&gt;%\n  mutate(Generation = as.numeric(Generation))\n\nGradients &lt;- traittemp %&gt;%\n  group_by(Generation, file) %&gt;%\n  do({\n    model &lt;- lm(offspring_count ~ scaleST0 + scaleST02, data = .)\n    data.frame(\n      Beta = coefficients(model)[2],\n      PB = summary(model)$coef[2, 4]\n    )\n  })\n\nGradients &lt;- Gradients %&gt;%\n  mutate(sig = if_else(PB &lt; 0.05 , \"Y\", \"N\"))\n\n\n\nggplot(Gradients, aes(x=Generation, y = Beta))+\n  geom_point(aes(color = sig))+\n  geom_smooth(fill=\"blue\")+\n  scale_color_manual(values = c(\"red\",\"grey\"))+\n  geom_hline(yintercept=0, linetype=\"dashed\", color = \"black\")+\n  theme(legend.position = \"none\",\n        panel.background = element_blank())+\n  facet_wrap(~file)\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#trait-evolution",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#trait-evolution",
    "title": "TwinStick Data Summary",
    "section": "Trait Evolution",
    "text": "Trait Evolution\nThis section should summarize the patterns of trait evolution\n\n\nCode\nfor(i in seq_along(Traits)){\n\n  plot &lt;- ggplot(data = TraitAvg, aes(x = as.numeric(Generation), y = !!sym(Traits[i])))+\n    geom_smooth(data = TraitAvg, aes(x = as.numeric(Generation), y = !!sym(Traits[i])), method = \"loess\") +\n    geom_point(data=allfiles, aes(x = as.numeric(Generation), y = !!sym(Traits[i]), color = offspring_count), size = 0.5, alpha =0.1)+\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\n  print(plot)\n}\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#gene-evolution",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#gene-evolution",
    "title": "TwinStick Data Summary",
    "section": "Gene Evolution",
    "text": "Gene Evolution\n\n\nCode\nfor(i in seq_along(Genes)){\n\n  plot &lt;- ggplot(data = GeneAvg, aes(x = as.numeric(Generation), y = !!sym(paste(\"mean.\",Genes[i], sep = \"\"))))+\n    geom_point(data = allfiles, aes(x = as.numeric(Generation), y = !!sym(Genes[i])), size=0.1, alpha = 0.02)+\n    geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y = !!sym(paste(\"mean.\",Genes[i], sep = \"\")), method = \"loess\")) +\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\n  print(plot)\n}\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#heatmap",
    "href": "DevBlog/posts/TwinStickEvolution1/TwinStick.html#heatmap",
    "title": "TwinStick Data Summary",
    "section": "Heatmap",
    "text": "Heatmap\n\n\nCode\nmaxwave = max(allfiles$Wave.Number)\n\nTwin3 &lt;- Twin3 %&gt;%\n  select(Wave.Number, Slime.ID, Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, \n         Tower.View.Range.Trait, Player.View.Range.Trait, Wall.View.Range.Trait, Sheep.View.Range.Trait, Slime.Attraction.Trait, \n         Tower.Attraction.Trait, Player.Attraction.Trait, Wall.Attraction.Trait, Sheep.Attraction.Trait, Slime.Optimal.Distance.Trait, \n         Speed.Trait, Turn.Rate.Trait, Sprint.Duration.Trait, Sprint.Cooldown.Trait, offspring_count) %&gt;%\n  filter(Wave.Number == maxwave)\n\npaletteLength &lt;- 50\nmyColor &lt;- colorRampPalette(c(\"blue\", \"white\", \"#ED2024\"))(paletteLength)\n# length(breaks) == length(paletteLength) + 1\n# use floor and ceiling to deal with even/odd length pallettelengths\n\n\nHeatmap &lt;- Twin3 %&gt;%\n  select(Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, \n         Tower.View.Range.Trait, Player.View.Range.Trait, Wall.View.Range.Trait, Sheep.View.Range.Trait, Slime.Attraction.Trait, \n         Tower.Attraction.Trait, Player.Attraction.Trait, Wall.Attraction.Trait, Sheep.Attraction.Trait, Slime.Optimal.Distance.Trait, \n         Speed.Trait, Turn.Rate.Trait, Sprint.Duration.Trait, Sprint.Cooldown.Trait)\n\nHeatmap &lt;- scale(Heatmap)\n\ncolnames(Heatmap) &lt;- c('Fitness', 'Main Resistance', 'Secondary Resistance', 'Slime View Range', 'Tower Viewe Range', 'Player View Range',\n                        'Wall View Range', 'Sheep View Range', 'Slime Attraction', 'Tower Attraction', 'Player Attraction', 'Wall Attraction',\n                        'Sheep Attraction', 'Slime Optimal Distance', 'Speed', 'Turn Rate', 'Sprint Duration', 'Sprint Cooldown')\n\nHeatmatrix2 &lt;- as.matrix(Heatmap)\n\nmyBreaks2 &lt;- c(seq(min(Heatmatrix2), 0, length.out=ceiling(paletteLength/2) + 1), seq(max(Heatmatrix2)/paletteLength, max(Heatmatrix2), \n                                                                                      length.out=floor(paletteLength/2)))\n\nheatmap1 = pheatmap(Heatmatrix2,\n         cluster_rows = TRUE, # don't cluster rows\n         cluster_cols = TRUE, # don't cluster columns\n         clustering_distance_cols = \"euclidean\",\n         clustering_distance_rows = \"euclidean\",\n         clustering_method = \"complete\",\n         kmeans_k = 20,\n         cellheight = 8,\n         fontsize_row = 8,\n         color = myColor,\n         breaks = myBreaks2,\n         border_color = NA)\n\nheatmap2 = pheatmap(Heatmatrix2,\n         cluster_rows = TRUE, # don't cluster rows\n         cluster_cols = TRUE, # don't cluster columns\n         clustering_distance_cols = \"euclidean\",\n         clustering_distance_rows = \"euclidean\",\n         clustering_method = \"complete\",\n         color = myColor,\n         breaks = myBreaks2)"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html",
    "title": "Testing Evolution in Project TwinStick",
    "section": "",
    "text": "Is it really an Evolutionary game?\nWhen we are developing our games, we perform extensive testing to make sure the underlying biological models are performing as expected. In the case of evolutionary games, we need to test that the population of enemies is indeed adapting the game conditions as we intended. This post is (I hope) the first in a series in which we document those tests.\nMy hope is that performing these tests in this format will serve as an organized archive of our analyses, improving reproducibility and rigor. I also have a vain glimmer of hope that some person other than me might actually be interested in this topic."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#project-twin-stick",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#project-twin-stick",
    "title": "Testing Evolution in Project TwinStick",
    "section": "PROJECT TWIN STICK",
    "text": "PROJECT TWIN STICK\nThis is intended to be an evolutionary shooter. The game is described in detail here."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#data",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#data",
    "title": "Testing Evolution in Project TwinStick",
    "section": "DATA",
    "text": "DATA\nIn this section, we ingest the data from whatever runs are relevant to the analysis. The data are written from the project in .csv files. The following code reads all .csv files from the working directory. It creates new variables for the source file name (file) and the number of offspring produced by each individual (offspring_count). It then appends all the data files into a single data frame called allfiles. I also create a few aggregations of the data by generating mean values of interest (traits, genes, fitness estimates) for each generation in each file (TraitAvg, GeneAvg, FitAvg)\n\n\nCode\nlibrary(tidyverse)\nlibrary(pheatmap)\n\n\nfiles &lt;- list.files(pattern = \"*.csv\", full.names = TRUE)\n\nallfiles = data.frame()\nfor(csv in files){\n  Twin3 &lt;- read.csv(csv, as.is=T, header=T)\n  Twin3['file'] = csv\n\n\nTwin3&lt;-Twin3%&gt;%\n  mutate(Unique.Slime.ID = paste(Wave.Number, \".\", Slime.ID))%&gt;%\n  mutate(Unique.Parent.One = paste(Wave.Number-1, \".\", Parent.One))%&gt;%\n  mutate(Unique.Parent.Two = paste(Wave.Number-1, \".\", Parent.Two))\n\n\ndf_parents &lt;- Twin3 %&gt;%\n  select(Unique.Parent.One, Unique.Parent.Two) %&gt;%\n  pivot_longer(cols = everything(), names_to = \"parent_type\", values_to = \"parent_id\")\n\n# Count the number of offspring for each parent\noffspring_counts &lt;- df_parents %&gt;%\n  group_by(parent_id) %&gt;%\n  summarise(offspring_count = n(), .groups = \"drop\")\n\noffspring_counts &lt;- offspring_counts%&gt;%\n  filter(parent_id != \"-1 . N/A\")\n\n\noffspring_counts&lt;- rename(offspring_counts, Unique.Slime.ID = parent_id)\n\n\n\nTwin3 &lt;- Twin3 %&gt;%\n  left_join(offspring_counts, by = \"Unique.Slime.ID\")%&gt;%\n  replace_na(list(offspring_count = 0))\n\nallfiles&lt;-rbind(allfiles,Twin3)\n\n}\n\n\n\nTraits &lt;- c(\"Main.Resistance.Trait\", \"Secondary.Resistance.Trait\", \"Speed.Trait\",\n           \"Tower.Attraction.Trait\", \"Slime.Optimal.Distance.Trait\", \"Turn.Rate.Trait\", \n           \"Slime.View.Range.Trait\", \"Tower.View.Range.Trait\")\n\nGenes &lt;- c(\"Main.Resistance.Gene\", \"Secondary.Resistance.Gene\", \"Speed.Gene\",\n           \"Tower.Attraction.Gene\", \"Slime.Optimal.Distance.Gene\", \"Turn.Rate.Gene\", \n           \"Slime.View.Range.Gene\", \"Tower.View.Range.Gene\")\n\nallfiles&lt;-allfiles%&gt;%\n  mutate(Generation=as.factor(Wave.Number))%&gt;%\n  mutate(offspring.count.Fitness = offspring_count)\n   \n\nTraitAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Trait\"), mean,  na.rm = TRUE))\n\nGeneAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Gene\"), list(mean = mean, var = var), na.rm = TRUE, .names = \"{.fn}.{.col}\"))\n\nFitAvg &lt;- allfiles %&gt;%\n  group_by(file, Generation) %&gt;%\n  summarize(across(ends_with(\"Fitness\"), list(mean = mean, var = var), na.rm = TRUE, .names = \"{.fn}.{.col}\"))\n\n\nThe allfiles dataframe contains the following variables (I also show a few columns of the example data):\n\n\nCode\ndata.dictionary &lt;- t(as.data.frame(head(allfiles)))\nknitr::kable(data.dictionary)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\nSlime.ID\n0\n1\n2\n3\n4\n5\n\n\nWave.Number\n0\n0\n0\n0\n0\n0\n\n\nPath.Distance.To.Player\n48.85652\n243.28900\n52.24455\n47.97002\n52.37562\n49.61573\n\n\nPlayer.Distance.Fitness\n6220.8410\n817.3569\n4242.2990\n886.9061\n840.3026\n11859.4700\n\n\nParent.One\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\n\n\nParent.Two\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\n\n\nMain.Type\nFire\nBalanced\nIce\nLaser\nFire\nBalanced\n\n\nSecondary.Type\nLightning\nLaser\nPlayer\nBalanced\nLaser\nBalanced\n\n\nMain.Resistance.Gene\n2.0608870\n1.9661370\n-0.2818377\n-0.4680732\n-0.8439584\n1.1251110\n\n\nMain.Resistance.Trait\n0.5781593\n0.5723717\n0.4327943\n0.4214026\n0.3986749\n0.5203083\n\n\nSecondary.Resistance.Gene\n0.01938968\n-0.98718220\n2.00895400\n-1.95939400\n-0.14754200\n1.69588300\n\n\nSecondary.Resistance.Trait\n0.1831496\n0.1484518\n0.2693818\n0.1202729\n0.1769885\n0.2542582\n\n\nSlime.View.Range.Gene\n1.4521710\n1.2083730\n-1.2260780\n0.5501021\n1.7734190\n-0.2817471\n\n\nSlime.View.Range.Trait\n9.846652\n9.624311\n7.359468\n9.014909\n10.135870\n8.235971\n\n\nTower.View.Range.Gene\n0.7422258\n-0.1091797\n1.7339480\n-0.6273459\n-5.1927860\n3.4309650\n\n\nTower.View.Range.Trait\n22.850260\n20.727070\n25.268240\n19.434840\n9.578748\n29.087540\n\n\nPlayer.View.Range.Gene\n-0.7063282\n-2.1725960\n1.6474010\n1.4230030\n1.4728720\n-0.9215398\n\n\nPlayer.View.Range.Trait\n3.356673\n2.760780\n4.570595\n4.442866\n4.471066\n3.261141\n\n\nWall.View.Range.Gene\n0.1313843\n0.4750734\n-1.5232850\n-3.8257190\n2.0445590\n0.9626993\n\n\nWall.View.Range.Trait\n5.131722\n5.393839\n4.013157\n2.857810\n6.702432\n5.781892\n\n\nSheep.View.Range.Gene\n1.7711210\n0.9314346\n-1.5420110\n-1.2949050\n0.2431266\n1.1810520\n\n\nSheep.View.Range.Trait\n6.462865\n5.756467\n4.001901\n4.152985\n5.215874\n5.961442\n\n\nSlime.Attraction.Gene\n-0.9736148\n2.7849460\n-4.7560740\n-1.4975330\n3.8921370\n-1.2803270\n\n\nSlime.Attraction.Trait\n0.4394477\n0.6673529\n0.2334345\n0.4074823\n0.7257239\n0.4206558\n\n\nTower.Attraction.Gene\n-0.4425031\n-1.4073980\n2.1533490\n-2.2012160\n-1.0032450\n5.0503550\n\n\nTower.Attraction.Trait\n-0.29616710\n-0.40190990\n0.01916635\n-0.48166660\n-0.35871090\n0.36383100\n\n\nPlayer.Attraction.Gene\n-0.6821441\n-1.5962090\n0.1492842\n-0.6433153\n5.3284170\n3.0868470\n\n\nPlayer.Attraction.Trait\n0.01473093\n-0.09919876\n0.11810670\n0.01958311\n0.64462790\n0.45092120\n\n\nWall.Attraction.Gene\n0.11956880\n-0.02190518\n-1.25375300\n1.15285900\n2.16463900\n1.75254500\n\n\nWall.Attraction.Trait\n-0.8776227\n-0.8813708\n-0.9099839\n-0.8470677\n-0.8113552\n-0.8266206\n\n\nSheep.Attraction.Gene\n0.8572116\n-2.7688480\n-1.5240110\n-1.0484580\n-1.1801490\n-0.6187063\n\n\nSheep.Attraction.Trait\n0.7710594\n0.5763453\n0.6499905\n0.6765333\n0.6692872\n0.6995852\n\n\nSlime.Optimal.Distance.Gene\n0.2664202\n-2.2980430\n-2.9115990\n-0.2503796\n-1.6853910\n-2.4088830\n\n\nSlime.Optimal.Distance.Trait\n0.27595890\n-0.03723812\n-0.11345930\n0.21528110\n0.03930581\n-0.05106586\n\n\nSpeed.Gene\n2.67080900\n-2.43531700\n0.79449970\n-0.09684456\n-0.07920066\n4.90996600\n\n\nSpeed.Trait\n3.594294\n1.761624\n2.809378\n2.480475\n2.486693\n4.657131\n\n\nTurn.Rate.Gene\n-2.0039470\n-1.0869590\n2.0893600\n1.9250450\n-0.7608740\n-0.4138883\n\n\nTurn.Rate.Trait\n0.1190994\n0.1453261\n0.2733563\n0.2652731\n0.1557471\n0.1674969\n\n\nSprint.Duration.Gene\n0.3580502\n1.4855350\n-2.5910690\n-4.1994710\n3.6484950\n0.9284849\n\n\nSprint.Duration.Trait\n2.611816\n2.958966\n1.717464\n1.296253\n3.567173\n2.788856\n\n\nSprint.Cooldown.Gene\n0.1790418\n-1.2494470\n3.2872270\n-2.1884230\n1.2849080\n2.4639170\n\n\nSprint.Cooldown.Trait\n2.7232060\n1.1139800\n4.8199400\n0.5039746\n3.9164200\n4.6078660\n\n\nX\nNA\nNA\nNA\nNA\nNA\nNA\n\n\nfile\n./geneWriteFile08_09_2023_15-22-57.csv\n./geneWriteFile08_09_2023_15-22-57.csv\n./geneWriteFile08_09_2023_15-22-57.csv\n./geneWriteFile08_09_2023_15-22-57.csv\n./geneWriteFile08_09_2023_15-22-57.csv\n./geneWriteFile08_09_2023_15-22-57.csv\n\n\nUnique.Slime.ID\n0 . 0\n0 . 1\n0 . 2\n0 . 3\n0 . 4\n0 . 5\n\n\nUnique.Parent.One\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n\n\nUnique.Parent.Two\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n-1 . N/A\n\n\noffspring_count\n17\n0\n8\n1\n0\n34\n\n\nGeneration\n0\n0\n0\n0\n0\n0\n\n\noffspring.count.Fitness\n17\n0\n8\n1\n0\n34\n\n\n\n\n\nVariables that end in .Gene are the values of the genome for that particular locus. Variables that end in .Trait are the values of the trait for that particular locus. Variables that end in .Fitness are the values of that particular Fitness component."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#experimental-conditions",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#experimental-conditions",
    "title": "Testing Evolution in Project TwinStick",
    "section": "EXPERIMENTAL CONDITIONS",
    "text": "EXPERIMENTAL CONDITIONS\nThe enemies in this game are slimes of several different types. These types correspond to the different damage types that can be caused by the player’s towers (Lightning, Ice, Fire, etc). Our initial idea is that the slimes of a specific type should be resistant to that type of damage. The average resistance of the whole population should increase over time if the player relies on only one type of tower.\nThe current resistance model is as follows:\nDamage Resistance = (Main.Type)0.6 + (Secondary.Type)0.4\nWhere Main.Type and Secondary.Type = 1 if they match the Damage Type and 0 if they do not.\nOur hypothesis is that resistance of the population will adapt to the damage type of the defense used. If true, this hypothesis predicts that the mean resistance of the population will increase over time, primarily through the proliferation of slimes of a Type that matches the Damage Type.\nWe constructed a simple defense in the center of the playing area, consisting of three towers. The only Fitness Function at this time is related to Path Distance to the Player (the closer they get to the player, the more fitness they acquire)."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#results",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#results",
    "title": "Testing Evolution in Project TwinStick",
    "section": "RESULTS",
    "text": "RESULTS\n\nSlime Types\nEach Slime has a Main.Type and a Secondary.Type. These types use the ~.Resistance.~ category to confer resistance to the appropriate damage type.\nThe following code creates two summary dataframes with the suffix ~Typecounts that count the number of slimes of each ~.Type in each generation for each replicate. It then creates the graphs of ~Type frequency over time.\n\n\nCode\nMainTypecounts &lt;- allfiles %&gt;%\n  group_by(Main.Type, Generation, file) %&gt;%\n  summarise(Main.count = n(), .groups = \"drop\")\n\nSecondaryTypecounts &lt;- allfiles %&gt;%\n  group_by(Secondary.Type, Generation, file) %&gt;%\n  summarise(Secondary.count = n(), .groups = \"drop\")\n\n            \n\nggplot(MainTypecounts, aes(x = Generation, y = Main.count, fill = as.factor(Main.Type))) +\n  geom_col(position = \"stack\") +\n  labs(x = \"Generation\", y = \"Count\", fill = \"Main Slime Type\") +\n  theme_minimal()+\n  facet_wrap(~file, ncol=2)\n\n\n\n\n\nCode\nggplot(SecondaryTypecounts, aes(x = Generation, y = Secondary.count, fill = as.factor(Secondary.Type))) +\n  geom_col(position = \"stack\") +\n  labs(x = \"Generation\", y = \"Count\", fill = \"Secondary Slime Type\") +\n  theme_minimal()+\n  facet_wrap(~file, ncol=2)\n\n\n\n\n\nThese results do not align with the predictions of our hypothesis. There is a modest increase in the Lightning Secondary.Type."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#slime-fitness",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#slime-fitness",
    "title": "Testing Evolution in Project TwinStick",
    "section": "Slime Fitness",
    "text": "Slime Fitness\nIn most cases, it is useful to summarize the behavior of the fitness function for each experiment. In this case, the fitness function calculates a value of 50,000/(distance to player +1). I will also reverse calculate that for visualization. We then use Roulette Wheel selection to determine the parents of the next generation.\n\n\nCode\nggplot(allfiles, aes(x=Wave.Number, y= Path.Distance.To.Player))+\n  geom_jitter(aes(x=Wave.Number, y= Path.Distance.To.Player, color = offspring_count, alpha = offspring_count))+\n  geom_smooth()+\n  facet_wrap(~file, ncol = 2)+\n  scale_color_continuous(low=\"blue\", high = \"red\")\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\nWarning: Removed 11196 rows containing non-finite values (`stat_smooth()`).\n\n\nWarning: Removed 11196 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCode\nggplot(allfiles, aes(x=Wave.Number, y= Player.Distance.Fitness))+\n  geom_jitter(aes(x=Wave.Number, y= Player.Distance.Fitness, color = offspring_count, alpha = offspring_count))+\n  geom_smooth()+\n  facet_wrap(~file, ncol = 2)+\n  scale_color_continuous(low=\"blue\", high = \"red\")\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nCode\nggplot(allfiles, aes(x=Path.Distance.To.Player, y = Player.Distance.Fitness))+\n  geom_point(aes(x=Path.Distance.To.Player, y = Player.Distance.Fitness), alpha = 0.5)+\n  facet_wrap(~file, ncol = 2)+\n  scale_color_continuous(low=\"blue\", high = \"red\")\n\n\nWarning: Removed 11196 rows containing missing values (`geom_point()`).\n\n\n\n\n\nCode\nggplot(data = FitAvg, aes(x = as.numeric(Generation), y = var.offspring.count.Fitness))+\n    geom_point()+\n    geom_smooth(method = \"loess\") +\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nCode\nggplot(allfiles, aes(x = as.factor(Wave.Number), y = log10(offspring_count))) + \n  geom_boxplot(fill=\"lightblue\") +\n  theme(legend.position = \"none\")+\n  facet_wrap(~file, ncol = 2)\n\n\nWarning: Removed 8419 rows containing non-finite values (`stat_boxplot()`)."
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#evolutionary-responses",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#evolutionary-responses",
    "title": "Testing Evolution in Project TwinStick",
    "section": "Evolutionary Responses",
    "text": "Evolutionary Responses\n\n\nCode\nGradientslong &lt;- data.frame()\nfor(i in seq_along(Traits)){\n\ntraittemp&lt;-allfiles%&gt;%\n  select(Generation, offspring_count, file, !!sym(Traits[i]))%&gt;%\n  group_by(Generation, file)%&gt;%\n  mutate(scaleST0 = scale(!!sym(Traits[i]), center = TRUE))%&gt;%\n  mutate(scaleST02 = scaleST0*scaleST0)%&gt;%\n  mutate(Generation = as.numeric(Generation))\n\nGradients &lt;- traittemp %&gt;%\n  group_by(Generation, file) %&gt;%\n  do({\n    model &lt;- lm(offspring_count ~ scaleST0 + scaleST02, data = .)\n    data.frame(\n      Beta = coefficients(model)[2],\n      PB = summary(model)$coef[2, 4],\n      Trait = Traits[i]\n    )\n  })\n\nGradients &lt;- Gradients %&gt;%\n  mutate(sig = if_else(PB &lt; 0.05 , \"Y\", \"N\"))\n\nGradientslong &lt;- rbind(Gradientslong, Gradients)\n\nG &lt;- ggplot(data = GeneAvg, aes(x = as.numeric(Generation), y = !!sym(Genes[i])))+\n    geom_point(data = allfiles, aes(x = as.numeric(Generation), y = !!sym(Genes[i])), size=0.1, alpha = 0.02)+\n    geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y = !!sym(paste(\"mean.\",Genes[i], sep = \"\")), method = \"loess\")) +\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\nP &lt;- ggplot(data = TraitAvg, aes(x = as.numeric(Generation), y = !!sym(Traits[i])))+\n    geom_smooth(data = TraitAvg, aes(x = as.numeric(Generation), y = !!sym(Traits[i])), method = \"loess\") +\n    geom_point(data=allfiles, aes(x = as.numeric(Generation), y = !!sym(Traits[i]), color = offspring_count), size = 0.5, alpha =0.1)+\n    theme(legend.position = \"none\") +\n    facet_wrap(~file, ncol = 2) \n\n\n\nS &lt;- ggplot(Gradients, aes(x=Generation, y = Beta))+\n  geom_point(aes(color = sig))+\n  geom_smooth(fill=\"blue\")+\n  scale_color_manual(values = c(\"grey\",\"red\"))+\n  geom_hline(yintercept=0, linetype=\"dashed\", color = \"black\")+\n  theme(legend.position = \"none\",\n        panel.background = element_blank())+\n  facet_wrap(~file)\n\nprint(G)\n\nprint(P)\n\nprint(S)\n\n}\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning in geom_smooth(data = GeneAvg, aes(x = as.numeric(Generation), y =\n!!sym(paste(\"mean.\", : Ignoring unknown aesthetics: method\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'"
  },
  {
    "objectID": "DevBlog/posts/TwinStickEvolution1/index.html#heatmap",
    "href": "DevBlog/posts/TwinStickEvolution1/index.html#heatmap",
    "title": "Testing Evolution in Project TwinStick",
    "section": "Heatmap",
    "text": "Heatmap\n\n\nCode\nmaxwave = max(allfiles$Wave.Number)\n\nTwin3 &lt;- allfiles %&gt;%\n  select(Wave.Number, Slime.ID, Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, \n         Tower.View.Range.Trait, Player.View.Range.Trait, Wall.View.Range.Trait, Sheep.View.Range.Trait, Slime.Attraction.Trait, \n         Tower.Attraction.Trait, Player.Attraction.Trait, Wall.Attraction.Trait, Sheep.Attraction.Trait, Slime.Optimal.Distance.Trait, \n         Speed.Trait, Turn.Rate.Trait, Sprint.Duration.Trait, Sprint.Cooldown.Trait, offspring_count) %&gt;%\n  filter(Wave.Number == maxwave)\n\npaletteLength &lt;- 50\nmyColor &lt;- colorRampPalette(c(\"blue\", \"white\", \"#ED2024\"))(paletteLength)\n# length(breaks) == length(paletteLength) + 1\n# use floor and ceiling to deal with even/odd length pallettelengths\n\n\nHeatmap &lt;- Twin3 %&gt;%\n  select(Player.Distance.Fitness, Main.Resistance.Trait, Secondary.Resistance.Trait, Slime.View.Range.Trait, \n         Tower.View.Range.Trait, Slime.Attraction.Trait, \n         Tower.Attraction.Trait, Slime.Optimal.Distance.Trait, \n         Speed.Trait, Turn.Rate.Trait)\n\nHeatmap &lt;- scale(Heatmap)\n\ncolnames(Heatmap) &lt;- c('Fitness', 'Main Resistance', 'Secondary Resistance', 'Slime View Range',\n                       'Tower View Range', 'Slime Attraction', 'Tower Attraction',\n                       'Slime Optimal Distance', 'Speed', 'Turn Rate')\n\nHeatmatrix2 &lt;- as.matrix(Heatmap)\n\nmyBreaks2 &lt;- c(seq(min(Heatmatrix2), 0, length.out=ceiling(paletteLength/2) + 1), seq(max(Heatmatrix2)/paletteLength, max(Heatmatrix2), \n                                                                                      length.out=floor(paletteLength/2)))\n\n\nheatmap2 = pheatmap(Heatmatrix2,\n         cluster_rows = TRUE, # don't cluster rows\n         cluster_cols = TRUE, # don't cluster columns\n         clustering_distance_cols = \"euclidean\",\n         clustering_distance_rows = \"euclidean\",\n         clustering_method = \"complete\",\n         color = myColor,\n         breaks = myBreaks2)"
  },
  {
    "objectID": "DevBlog/posts/welcome/index.html",
    "href": "DevBlog/posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#overview",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#overview",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "OVERVIEW",
    "text": "OVERVIEW\nObjective: Present an integrated collaboration framework for the Tickbase Outreach and Education projects that will facilitate integration into the datathon components of our annual meeting.\n\nFramework\nTeam\nProjects\nOpportunities"
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "FRAMEWORK",
    "text": "FRAMEWORK\n\nQuarto / RStudio\nGitHub Repository\nGitHub Pages"
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-1-qarto-rstudio",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-1-qarto-rstudio",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "FRAMEWORK 1: Qarto / RStudio",
    "text": "FRAMEWORK 1: Qarto / RStudio\nWe need a way to collaborate that:\n\nCan accomodate users of varying technical backgrounds.\nIs flexible in terms of publishing formats (html, websites, blogs, documents, presentations, etc).\nCan accomodate code exampes from the main data science languages (R, Python, Observable, etc).\n\nEnter Literate Programming with Quarto!"
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-2-github-repository",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-2-github-repository",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "FRAMEWORK 2: GitHub Repository",
    "text": "FRAMEWORK 2: GitHub Repository\nWe are rebuilding the Polymorphic Games website as a public GitHub repository. This allows us to:\n\nEasily invite collaborators to help us generate and modify content.\nHelp students from all technical backgrounds build skills in literate programming, reproducible research, and version control.\nFacilitate regular team updates through public blog posts.\nProvide much more detailed content about each project, allowing team members and collaborators to readily access information (How did that model work?) and assets (I want that one movie for my seminar!)."
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-3-github-pages",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#framework-3-github-pages",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "FRAMEWORK 3: GitHub Pages",
    "text": "FRAMEWORK 3: GitHub Pages\nWe are currently hosting the website using GitHub Pages. This allows us to:\n\nCollaborate on the website for the projects.\nEliminate the intermediary of a professional web developer* (Can you update this thing for me?).\nStill point to our domain name (www.polymorphicgames.com)."
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#team",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#team",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "TEAM",
    "text": "TEAM\nWow, I wish I had all the information so I could make a slide about our developers…\nOh wait… HERE IT IS!"
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#projects",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#projects",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "PROJECTS",
    "text": "PROJECTS\n\nOutbreak Simulator\nProject Drider\nTwinStick"
  },
  {
    "objectID": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#opportunities",
    "href": "DevBlog/posts/TickbaseSeminarFeb2023/index.html#opportunities",
    "title": "TICKBASE PRESENTATION - Datathon Preparation",
    "section": "OPPORTUNITIES",
    "text": "OPPORTUNITIES\n\nLesson plans, activities, demo ideas, use cases.\nModel improvements, feature additions.\nCommunications (blogs, website, youtube, etc)\n\n\n\nPOLYMORPHIC GAMES…GitHub Repo"
  },
  {
    "objectID": "DevBlog/posts/Falcon/index.html",
    "href": "DevBlog/posts/Falcon/index.html",
    "title": "Outbreak Simulator on Falcon!",
    "section": "",
    "text": "This is a demo scenario for Outbreak Simulator. A complete description of the project can be found here"
  },
  {
    "objectID": "DevBlog/posts/Falcon/index.html#graph-interpretation",
    "href": "DevBlog/posts/Falcon/index.html#graph-interpretation",
    "title": "Outbreak Simulator on Falcon!",
    "section": "GRAPH INTERPRETATION",
    "text": "GRAPH INTERPRETATION\n\nEpicurve\nThe following graph is an Epidemiological Curve using data from 20 runs of Outbreak Simulator. It shows the number of people in the various categories of the epidemiological compartment model under two conditions - Airports on and off.\n\n\nCode\nfile_list1 &lt;- list.files(pattern = \"*Walk.*\\\\.csv$\") \nfile_list2 &lt;- list.files(pattern = \"*Fly.*\\\\.csv$\")\n\n\ndf1 &lt;- file_list1 %&gt;% \n  map_df(~read_csv(., show_col_types = FALSE) %&gt;%\n           mutate(source_file = .x, Airports = \"OFF\")) \n\ndf2 &lt;- file_list2 %&gt;% \n  map_df(~read_csv(., show_col_types = FALSE) %&gt;%\n           mutate(source_file = .x, Airports = \"ON\")) \n\ndf &lt;- rbind(df1, df2)\n\n\n\n\nCode\ndf&lt;-df%&gt;%\n  mutate_at(c(1:295), as.numeric)\n\ndftotal &lt;- df%&gt;%\n  select(Time, source_file, Airports, starts_with(\"Totals_\"))%&gt;%\n  rename(Time=Time,\n          S=Totals_S,\n         E=Totals_E,\n         V=Totals_V,\n         I=Totals_I,\n         R=Totals_R,\n         D=Totals_D,\n         source_file=source_file,\n         Airports = Airports)\n\nfor (i in 1:length(dftotal$Time)){\n  \n  dftotal$dS[i] &lt;- dftotal$S[i]-dftotal$S[i+1]\n  dftotal$dR[i] &lt;- dftotal$R[i+1]-dftotal$R[i]\n  dftotal$dI[i] &lt;- dftotal$I[i+1]-dftotal$I[i]\n  dftotal$dD[i] &lt;- dftotal$D[i+1]-dftotal$D[i]\n\n}\n\n\nWarning: Unknown or uninitialised column: `dS`.\n\n\nWarning: Unknown or uninitialised column: `dR`.\n\n\nWarning: Unknown or uninitialised column: `dI`.\n\n\nWarning: Unknown or uninitialised column: `dD`.\n\n\nCode\ndftotal&lt;- dftotal%&gt;%\n  mutate(N= S+E+I+V+R+D)%&gt;%\n  mutate(Beta = dS*N/(S*I+1))%&gt;%\n  mutate(Gamma = dD/(I+1))%&gt;%\n  mutate(R0 = Beta/Gamma)%&gt;%\n  filter(Beta&lt;10)%&gt;%\n  filter(R0&lt;10^3)\n\ndflong&lt;-dftotal%&gt;%\n  pivot_longer(cols = c(\"S\", \"E\", \"I\",\n                        \"V\", \"R\", \"D\"),names_to = \"Compartment\", values_to = \"Count\")\n\ndflong &lt;- dflong%&gt;%\n  mutate(Compartment = recode(Compartment, \n         S = \"Susceptible\",\n         E = \"Exposed\",\n         I = \"Infected\",\n         V = \"Vaccinated\",\n         R = \"Recovered\",\n         D = \"Deceased\"))%&gt;%\n  filter(Compartment != \"Vaccinated\")\n\n\n\n\nCode\nSus&lt;-dflong%&gt;%\n  filter(Compartment == \"Susceptible\")\n\nggplot(dflong, aes(x=Time, y = Count/10^6,  color=as.factor(Compartment)))+\n  geom_smooth()+\n  geom_point(size=0.1, alpha=0.1)+\n \n   labs(\n    title = \"Epidemiological Curve\",\n    subtitle = \"H1N1 Influenza\",\n    caption = \"Data from 20 runs of Outbreak Simulator.\",\n    tag = \"Figure 1\",\n    x = \"Time (h)\",\n    y = \"Number of Individuals (millions)\",\n    colour = \"Compartment\"\n  )+\n   scale_colour_brewer(type = \"seq\", palette = \"Spectral\")+\n  facet_wrap(~Airports)\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\nWarning: Computation failed in `stat_smooth()`\nComputation failed in `stat_smooth()`\nCaused by error in `gam.reparam()`:\n! NA/NaN/Inf in foreign function call (arg 3)"
  },
  {
    "objectID": "DevBlog/posts/Falcon/index.html#but-what-about..-states",
    "href": "DevBlog/posts/Falcon/index.html#but-what-about..-states",
    "title": "Outbreak Simulator on Falcon!",
    "section": "But what about….. STATES????",
    "text": "But what about….. STATES????\n\n\nCode\nstateslong &lt;- df %&gt;%\n  pivot_longer(cols = 2:295,\n               names_to = c(\"State\", \"Compartment\"),\n  names_pattern = \"(.+?)_(.)\",\n  values_to = \"Count\")\n\nfewerstates&lt;-stateslong%&gt;%\n  filter(State == \"Washington\" | State == \"Idaho\"\n         | State ==\"California\" | State == \"Oregon\"\n         )%&gt;%\n    mutate(Compartment = recode(Compartment, \n         S = \"Susceptible\",\n         E = \"Exposed\",\n         I = \"Infected\",\n         V = \"Vaccinated\",\n         R = \"Recovered\",\n         D = \"Deceased\"))%&gt;%\n  filter(Compartment != \"Vaccinated\")\n\n\nggplot(fewerstates, aes(x=Time, y = Count/10^6, color = Compartment))+\n  geom_point(size=0.1, alpha=0.1)+\n  facet_grid(State~Airports)+\n   labs(\n    title = \"Epidemiological Curve\",\n    subtitle = \"H1N1 Influenza\",\n    caption = \"Data from 20 run2 of Outbreak Simulator.\",\n    tag = \"Figure 2\",\n    x = \"Time (h)\",\n    y = \"Number of Individuals (millions)\",\n    colour = \"Compartment\"\n  )+\n   scale_colour_brewer(type = \"seq\", palette = \"Spectral\")"
  },
  {
    "objectID": "DevBlog/posts/Falcon/index.html#super-advanced-epidemiology",
    "href": "DevBlog/posts/Falcon/index.html#super-advanced-epidemiology",
    "title": "Outbreak Simulator on Falcon!",
    "section": "SUPER ADVANCED EPIDEMIOLOGY",
    "text": "SUPER ADVANCED EPIDEMIOLOGY\nReal time R0 calculations.\nR0, also known as the basic reproduction number, is a measure of the average number of secondary infections produced by a single infectious individual in a completely susceptible population. Calculating R0 from time series values of S (Susceptible), I (Infected), and R (Recovered) can be done using a mathematical model, such as the Susceptible-Infected-Recovered (SIR) model.\nThe SIR model is a set of ordinary differential equations that describe the dynamics of infectious diseases. The equations are:\ndS/dt = -β * S * I / N dI/dt = β * S * I / N - γ * I dR/dt = γ * I where:\nS is the number of susceptible individuals I is the number of infected individuals R is the number of recovered individuals N is the total population (N = S + I + R) β (beta) is the transmission rate per contact γ (gamma) is the recovery rate The basic reproduction number R0 is given by the formula:\nR0 = β / γ\nIn order to calculate R0 from time series data of S, I, and R, you’ll need to estimate the values of β and γ. One way to do this is to use curve-fitting techniques to fit the SIR model to your data. Once you have estimates for β and γ, you can calculate R0 using the formula above.\nHere’s an example using R and the deSolve package to fit the SIR model to sample data and estimate R0:\n\n\nCode\nggplot(dflong, aes(x=Time, y= R0))+\n  geom_smooth()+\n  labs(\n    title = \"Basic Reproduction Rate\",\n    subtitle = \"H1N1 Influenza\",\n    caption = \"Data from a single run of Outbreak Simulator.\",\n    tag = \"Figure 3\",\n    x = \"Time (h)\",\n    y = \"R0\"\n  )+\n   scale_colour_brewer(type = \"seq\", palette = \"Spectral\")+\n  geom_hline(yintercept = 1, color = \"red\", linetype = 3)+\n  facet_wrap(~Airports)\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nCode\nggplot(dflong, aes(x=Time, y= Beta))+\n  geom_smooth()+\n  labs(\n    title = \"SIR parameters: Beta\",\n    subtitle = \"H1N1 Influenza\",\n    caption = \"Data from a single run of Outbreak Simulator.\",\n    tag = \"Figure 4\",\n    x = \"Time (h)\",\n    y = \"Parameter Estimate\"\n  )+\n   scale_colour_brewer(type = \"seq\", palette = \"Spectral\")+\n  geom_hline(yintercept = .5, color = \"red\", linetype = 3)+\n  facet_wrap(~Airports)\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\nCode\nggplot(dflong, aes(x=Time, y= Gamma))+\n  geom_smooth()+\n  labs(\n    title = \"SIR parameters: Gamma\",\n    subtitle = \"H1N1 Influenza\",\n    caption = \"Data from a single run of Outbreak Simulator.\",\n    tag = \"Figure 4\",\n    x = \"Time (h)\",\n    y = \"Parameter Estimate\"\n  )+\n   scale_colour_brewer(type = \"seq\", palette = \"Spectral\")+\n  geom_hline(yintercept = 0, color = \"red\", linetype = 3)+\n  facet_wrap(~Airports)\n\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'"
  },
  {
    "objectID": "DevBlog/index.html",
    "href": "DevBlog/index.html",
    "title": "DevBlog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nTwinStick Data Summary\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nOutbreak Simulator on Falcon!\n\n\n\n\n\nHeadless mode allows for many replicates!\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\nTesting Evolution in Project TwinStick\n\n\n1 - The Evolution of Damage Resistance\n\n\nHow can we encode a damage resistance game mechanic that interacts well with a generational model of evolution?\n\n\n\n\n\n\nAug 9, 2023\n\n\nBarrie D. Robison\n\n\n\n\n\n\n  \n\n\n\n\nOutbreakSim GUI\n\n\n\n\n\n\n\nDevelopment\n\n\n\n\n\n\n\n\n\n\n\nJun 15, 2023\n\n\nCarson Rueber\n\n\n\n\n\n\n  \n\n\n\n\nTICKBASE PRESENTATION - Datathon Preparation\n\n\nFebruary 27, 2023\n\n\n\n\nSeminar\n\n\nTickbase\n\n\nDatathon\n\n\n\n\nOverview of the Tickbase game projects.\n\n\n\n\n\n\nFeb 27, 2023\n\n\nBarrie Robison\n\n\n\n\n\n\n  \n\n\n\n\nOUTBREAK SIMULATOR\n\n\nPreliminary Overview\n\n\n\n\nDevelopment\n\n\nTickbase\n\n\nModeling\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nFeb 6, 2023\n\n\nCarson Rueber\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nFeb 3, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "DevBlog/about.html",
    "href": "DevBlog/about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "Education/index.html",
    "href": "Education/index.html",
    "title": "Education",
    "section": "",
    "text": "The best way to explain the concept is to frame our video games in the context of the “ingredients” of evolution:\n\nVariation\nInheritance\nSelection\nTime\n\nWhen these components are present, it leads to Adaptation.\n\n\nThink about the enemies in the old school video games that I used to play in arcades. Space Invaders, Asteroids, Centipede, Tempest, etc. What kinds of variation can you describe in these enemies? In Space Invaders, you had three types of aliens in each wave, plus the occasional bonus flying saucer. In Centipede and Tempest, you actually had categorically different enemy types that varied in how they looked and in their capabilities. Below you can see a few examples of what I mean:\n\nSpace InvadersCentipedeTempest\n\n\n Enemy variation in Space Invaders includes the shape of each alien type (four types), but also their position in the armada (each type has its own row) and their speed of movement (which is adjusted based on how many remain in each wave). For now, we will ignore the flying saucer that passes across the top of the screen. The game increases in difficulty by having the movement speed of each wave increase. Ironically, the increased movement speed of the aliens within a wave as the population size was reduced was an unintended function of the increased frame rate achieved by having fewer aliens draw calls.\n\n\n Centipede includes enemy types with very different behaviors and abilities. The segmented centipede can split into component parts. Fleas drop vertically, leave a trail of mushrooms, and take two hits to destroy. Spiders move in a diagonal zig zag pattern. Scorpions move horizontally across the screen and turn mushrooms poisonous. Each wave the game difficulty increases by changing the behavior and segment number of the centipede.\n\n\n While not as famous as Space Invaders or Centipede, Tempest was one of my favorite games in the early 80s. The player navigated their ship across various geometric shapes, shooting at different types of enemies with different capabilities. These included player capturing Flippers, lane electrifying Pulsars, and obstacle creating Spikers. So many quarters gone…\n\n\n\nThis variation is a big part of what makes video games exciting. The difficulty in video games is usually increased over time by introducing new variations of enemies, changing the enemies’ capabilities (like speed or fire rate) over time, or increasing the number of enemies. The problem (as we see it) is that these variations are introduced as part of a script that is programmed and balanced by the game developers. Beating the game means memorizing the script.\n\n\n\nThe addition of an inheritance model is the primary differentiator in our games that creates adaptation.\nIn most games, there is no relationship between enemies within a wave or between waves. They are instantiated (spawned) with developer defined traits at a specified rate, location, and time (or level or wave). This is the key difference in the games that our lab creates. In our games, the enemies traits are specified by digital genomes that they pass on to their offspring through a form of reproduction. If the enemy has a speed value of 4, that means that when it reproduces, its offspring inherit that speed value of 4. Most of the games we work on specify about 40 to 80 “genes” in the enemy genome, each of which can influence one or more game traits such as speed, fire rate, morphology, behavior, health, armor, resistances, etc.\n\n\n\nSelection occurs when there is a correlation between a trait (say… hit points or movement behavior) and Fitness. In biological populations, Fitness is usually defined in terms of the number of offspring produced by a given individual. We often measure proxies for fitness in empirical biology that are typically predictive of (or at least correlated with ) Fitness, such as seed set in plants, survivorship, or number of eggs. In our games, we can make explicit linkages between performance and fitness using Fitness Functions.\nFor example, in Darwin’s Demons the enemies accrue Aggression by moving downward on the screen. The closer they get to the bottom, the higher their Aggression score. if they move past the player and off the bottom of the screen, their Aggression score gets an even larger boost. After each wave, the enemies with the highest Aggression score also have the highest probability of mating and producing offspring. Thus, we have created an explicit link in which Aggression is correlated with Fitness (number of offspring). Our games often have more than one of these Fitness Functions. For example, the Protean Swarm in Darwin’s Demons can also increase their mating chance with Accuracy (which measures how often they shoot at the player and how close they came to hitting the player) and Lifetime (which measures how long they last on the screen) .\nIf we turn off the fitness functions, then after each wave the enemies undergo random mating. Adaptive evolution does not occur, but the enemy traits might still evolve randomly because of Random Genetic Drift.\n\n\n\nThe concept of time in video games is often defined in terms of waves or levels. Both of these terms imply a progression toward the game’s goal, along with a corresponding increase in difficulty. In our games, we usually specify time in terms of generations. A wave of enemies begin the game, the player defeats them, and then the next wave is created with Inheritance using a mating function specified as described above. As the generations (waves) proceed, the enemies with traits that are best able to optimize the fitness functions have more offspring, and the population adapts to the game play conditions. Most of these conditions are created by player choices and playstyle, and thus the enemies adapt to the player. Difficulty increases organically and repeated gameplay often creates novel adaptive solutions to the same play style.\n\n\n\n\nWe reasoned that playing these types of games might have implications for STEM education. The success of the player is based on her comprehension and application of principles of evolutionary biology. The parallels to real world examples are numerous, and include the rapid evolution of antibiotic resistance in microbial pathogens, adaptation of crop pests to chemical and biological control measures, and behavioral adaptation to captivity in domesticated animals.\nAdding biological evolution to video games makes the games better for the game player and facilitates player comprehension of complex concepts that are hard to teach."
  },
  {
    "objectID": "Education/index.html#get-involved",
    "href": "Education/index.html#get-involved",
    "title": "Education",
    "section": "Get Involved",
    "text": "Get Involved\nIf you are interested in joining the lab and working in the studio, reach out to me by email."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "POLYMORPHIC GAMES",
    "section": "",
    "text": "Polymorphic Games is an experimental video game development studio based at the University of Idaho. We develop video games, interactive simulations, and visualizations that feature STEM concepts as core mechanics.\nOur main focus is Evolutionary Games that feature enemies that adapt to the player using mathematical models of biological evolution.\nWe have also collaborated with many different researchers to help them represent their model systems as interactive simulations or dynamic visualizations.\n\nEVOLUTIONARY GAMES\nInstead of pre-programming, scripted enemy behaviors to escalate difficulty, our games use populations of creatures that evolve specifically to beat your strategy. Each creature has its own traits that it can pass onto its offspring. After you beat one wave of creatures, the creatures that were the hardest to beat reproduce and you’ll fight their offspring in the next wave. Evolving traits include features like size, speed, damage, resistances, and behavior. We use real principles of evolutionary biology to create a model that includes all the components of real evolution — variation, inheritance, selection, and time — just operating at a much faster pace. This creates dynamic enemies that adapt to how YOU play the game. We just give evolution the space to work.\nLearn more about our games…\n\n\nDEVELOPMENT MODEL\nOur studio is based on the University of Idaho campus and populated by undergraduate students. A university setting is the one place where you can find programmers, artists, writers, musicians, marketers, and biologists — everyone you need to make a video game with foundations in evolutionary biology. We hire insanely talented teams of undergraduate students to develop our games. This gives us a team that can think outside the box, and it provides a great student experience. Our employees get to build skills in communication, leadership, and collaboration that they take with them when they graduate, all while honing their skills in their own trade.\nLearn more about our team…\n\n\nSUPPORT\nPolymorphic Games has been made possible through grants and support from the following:\n\n\n\n\n\n\n  Funding Sources:  Polymorphic Games\n  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  \n  \n    \n    \n      Total Award\n      Studio Funding\n      Sponsor\n      Title\n      CoPIs\n      PI\n      Start\n      End\n      Projects\n    \n  \n  \n    $936,605\n$234,492\nNSF\nCollaborative Research: BEE: Ecological and coevolutionary feedbacks in multi-mutualist communities.\nRobison\nD. Althoff\n4/2022\n4/2025\nTBD\n    $5,830,709\n$400,000\nNSF\nRII Track-2 FEC: Leveraging Big Data to Improve Prediction of Tick-Borne Disease Patterns and Dynamics.\nRobison, Harris, Shi\nX. Ma\n9/2020\n9/2024\nOutbreak Simulator, Project Drider, TwinStick\n    $74,700\n$74,700\nIGEM\nDarwin’s Demons mobile.\nSoule\nRobison\n7/2019\n7/2020\nEvolvy Bugs\n    $33,801\n$33,801\nNSF BEACON\nSalmon Run: An Evolutionary Ecology Educational Game.\nRobison, Blackwood, Soule\nR. Pennock\n7/2018\n7/2019\nSalmon Run\n    $67,600\n$67,600\nIGEM\nAn evolutionary approach to procedural opponent generation in video games.\nSoule\nRobison\n7/2017\n7/2018\nDarwin's Demons, Project Hastur\n    $99,328\n$99,328\nNSF BEACON\nTeaching evolution through game based simulation.\nRobison\nSoule\n5/2016\n8/2017\nDarwin's Demons, Project Hastur\n    $65,000\n$65,000\nVandal Ideas Program\nPolymorphic Games – an interdisciplinary game design studio.\nSoule, Hall, Bukvich, Caisely, Bennett, Nicotra, Kelly-Riley, Tanner, Clevely, Bird\nRobison\n7/2016\n8/2017\nDarwin's Demons"
  },
  {
    "objectID": "People/index.html",
    "href": "People/index.html",
    "title": "PEOPLE",
    "section": "",
    "text": "I am a Professor of Biological Sciences at the University of Idaho, where I study evolution and adaptation using an unusual mixture of model systems. Over the course of my career, I have conducted research on the genetic basis of quantitative traits in Salmonids, behavioral genomics and adaptation to captivity in zebrafish, and the implementation of evolutionary models in video games. I taught Genomics and General Genetics for 15 years, and I now teach various courses in Data Science as part of our new Graduate Certificate in Professional Applications of Data Science.\nBarrie’s Website\n\n\n\n\n\n\n\nI am a Professor of Computer Science at the University of Idaho, and am also currently serving as Department Chair. My research interests include evolutionary computation, artificial intelligence, genetic algorithms, and evolutionary video games. I am also active in computer science education through teacher training and summer camps. I teach courses in programming at the undergraduate and graduate levels.\nTerry’s Website\nProgramming Chaos Youtube"
  },
  {
    "objectID": "People/index.html#landon-wright",
    "href": "People/index.html#landon-wright",
    "title": "PEOPLE",
    "section": "Landon Wright",
    "text": "Landon Wright\n\nCreative Director, UIdaho VTD graduate, I like to make stuff.\nLandon’s Instagram"
  },
  {
    "objectID": "People/index.html#carson-rueber",
    "href": "People/index.html#carson-rueber",
    "title": "PEOPLE",
    "section": "Carson Rueber",
    "text": "Carson Rueber\n\nI’m a third year student at the University of Idaho majoring in Computer Science with a Minor in French. I am the lead programmer on the [Outbreak Simulator] project, and have been working for Polymorphic Games since the summer of 2021.\nMy Blog My GitHub"
  },
  {
    "objectID": "People/index.html#jonna-waage",
    "href": "People/index.html#jonna-waage",
    "title": "PEOPLE",
    "section": "Jonna Waage",
    "text": "Jonna Waage\n\nI am a third year undergraduate computer science major and mathematics minor at the University of Idaho. I have been a software developer with Polymorphic Games since the Fall of 2022. My current project is the TwinStick game, where I am working on the AI that controls the defensive towers."
  },
  {
    "objectID": "People/index.html#ava-rummler",
    "href": "People/index.html#ava-rummler",
    "title": "PEOPLE",
    "section": "Ava Rummler",
    "text": "Ava Rummler\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD I’m an MFA Candidate and Instructor of record at the University of Idaho where I practice and teach design. My practice focuses on human interaction through different principles of User Experience design and research. My professional experience ranges from App Design to Art Direction and I’m now the I’m the UX Designer for TwinStick!\n======= I’m an MFA Candidate and Instructor of record at the University of Idaho where I practice and teach design. My practice focuses on human interaction through different principles of user experience design and research. My professional experience ranges from App Design to Art Direction and I’m now UX Designer for TwinStick! Here, I implement my design and research experiences to create accessible screens for TwinStick players to learn about evolution and data science. You can see how the UI/UX of project TwinStick is coming together here! &gt;&gt;&gt;&gt;&gt;&gt;&gt; d5ca71142af61566ccaf167db56d5c5571d66967\nAva’s Portfolio\nAva’s Linkedin"
  },
  {
    "objectID": "People/index.html#justin-riggs",
    "href": "People/index.html#justin-riggs",
    "title": "PEOPLE",
    "section": "Justin Riggs",
    "text": "Justin Riggs"
  },
  {
    "objectID": "People/index.html#elisha-coad",
    "href": "People/index.html#elisha-coad",
    "title": "PEOPLE",
    "section": "Elisha Coad",
    "text": "Elisha Coad"
  },
  {
    "objectID": "People/index.html#kristin-martinet",
    "href": "People/index.html#kristin-martinet",
    "title": "PEOPLE",
    "section": "Kristin Martinet",
    "text": "Kristin Martinet"
  },
  {
    "objectID": "Games/ProjectHastur/index.html#end-of-webgl-test",
    "href": "Games/ProjectHastur/index.html#end-of-webgl-test",
    "title": "PROJECT HASTUR",
    "section": "End of WebGL Test",
    "text": "End of WebGL Test"
  },
  {
    "objectID": "Games/DarwinsDemons/index.html",
    "href": "Games/DarwinsDemons/index.html",
    "title": "DARWIN’S DEMONS",
    "section": "",
    "text": "link aslkjf"
  },
  {
    "objectID": "Games/TwinStick/index.html#game-footage",
    "href": "Games/TwinStick/index.html#game-footage",
    "title": "TWIN STICK",
    "section": "GAME FOOTAGE",
    "text": "GAME FOOTAGE\nVideo"
  },
  {
    "objectID": "Games/TwinStick/index.html#stuff",
    "href": "Games/TwinStick/index.html#stuff",
    "title": "TWIN STICK",
    "section": "STUFF!",
    "text": "STUFF!"
  },
  {
    "objectID": "Games/TwinStick/Towers.html",
    "href": "Games/TwinStick/Towers.html",
    "title": "Towers",
    "section": "",
    "text": "There are 6 different kinds of towers, each of them have the ability to damage all slimes except for the slimes that have a resistance to that tower’s type."
  },
  {
    "objectID": "Games/TwinStick/Towers.html#projectiles",
    "href": "Games/TwinStick/Towers.html#projectiles",
    "title": "Towers",
    "section": "Projectiles",
    "text": "Projectiles\nEach tower has their own special projectile depending on the type."
  },
  {
    "objectID": "Games/TwinStick/Towers.html#ai",
    "href": "Games/TwinStick/Towers.html#ai",
    "title": "Towers",
    "section": "AI",
    "text": "AI\nThe towers will be able to track the nearest slime and shoot at it once the slime gets close enough. This AI is important because otherwise the towers would not know where or if to shoot. This is done with a function that with every update, it goes through the array of all slimes and finds the distance between the tower and each of the slimes. The tower then rotates to point at that slime and shoot their specific projectile. If the slime has that resistance, it will not damage it. For example, if an acid tower shoots a bomb and hits a acid slime, nothing will happen but if it hits a fire slime, the slime will take damage."
  },
  {
    "objectID": "Games/TwinStick/UXUI.html",
    "href": "Games/TwinStick/UXUI.html",
    "title": "UX/UI",
    "section": "",
    "text": "User Experience is a critical part of TwinStick because of the educational elements involved. This means that complex information must be easy for players to understand to not only educate them on evolving slimes, but inform their decisions on how to interact with the next generation of slimes.\nData involving slime traits, fitness, and their offspring is all information that players should be able to interpret on the screens displayed between each round of generations. UX/UI principles play a key roll in the design of these screens for this reason."
  },
  {
    "objectID": "Games/TwinStick/UXUI.html#low-fidelity-explorations",
    "href": "Games/TwinStick/UXUI.html#low-fidelity-explorations",
    "title": "UX/UI",
    "section": "Low Fidelity Explorations",
    "text": "Low Fidelity Explorations\nVideo\nThis is a prototype of how different slimes and their off spring can be communicated. Since evolution is an important factor of understanding transformed traits from offspring to offspring, pedigrees can be a helpful tool for players.\nVideo\nThis prototype explores what it would look like if players were able to pick specific slimes to learn more about. This communicates what different “families” look like in terms of slimes and their offspring.\nVideo\nThe slimes in TwinStick are complex when it comes to their specific traits and fitness. It’s important to categorize the slimes for the player to understand their characteristics. This prototype explores the layout of these categories and how the player could potentially interact with these controls.\nAnother factor of this prototype is the potential graph placement and extended information on each slime in a family. The viewer would be able to get a description of each slime along with some important information on their traits, fitness, and maybe even their placement on the graph provided. Comparing and contrasting each slime is also an effectuve educational tool, so this prototype also explores what that would look like.\nVideo\nAs traits become more official, more styles and information architecture styles can be explored as shown by the more “dark mode” approach. This is an exploration of categorizing every offspring in their “fitness,” but still keeping them all on the same screen because of the parents’ ability to have offspring in different fitness categories. Because this requires multiple slimes to be displayed, a different approach to pedigrees was explored.\nThe traits on the side operate as controls to see each type of graph that the player can access. In this prototype, slimes have a value to each trait that’s displayed on the graph. The trait is highlighted with their prospective graph along with the value displayed under the description of the slime and their spot on the scatter plot.\nVideo\nOn occasions where the player wants to compare slimes with the same trait, they can switch between the slime they’d like to see. Their scatter plot point is highlighted with their prospective point, which changes if the player selects another slime in the pedigree. The values in the slime description box also change to coincide with the slime selected.\nVideo\nExploring more of the graph features, this is a prototype of what it could look like if a player wants to select a point on the scatter plot to see which slime coincides with that point. An image of the slime and their information will appear for the player to see.\nVideo\nIf the player would want to switch between pedigrees, this prototype shows what that would potentially look like. All the information would be changed according to the player’s selection."
  },
  {
    "objectID": "Games/index.html",
    "href": "Games/index.html",
    "title": "Games",
    "section": "",
    "text": "Darwin’s Demons is an arcade style space shooter in which you battle a population of evolving aliens. The alien’s morphology, fire type, and behaviors are all encoded by a digital genome. The aliens that are best able to shoot or evade you reproduce to make the next generation.\n\nProject Hastur is an evolutionary tower defense game. Defend humanity against the ever changing threat of the alien Proteans. Project Hastur combines elements of 3D tower defense and real-time strategy with models of biological evolution to create a uniquely challenging experience."
  },
  {
    "objectID": "Games/index.html#outbreak-simulator",
    "href": "Games/index.html#outbreak-simulator",
    "title": "Games",
    "section": "OUTBREAK SIMULATOR",
    "text": "OUTBREAK SIMULATOR\nOutbreak Simulator is a tool that allows users to simulate the spread of an infectious disease and explore the impact of different interventions. The simulation can be used to promote systems thinking and data science literacy, as users can see how different factors interact to influence the spread of the disease and how data can be used to track, visualize, and understand the outbreak. Outbreak Simulator can be used in educational, research, and public health settings to help people gain a better understanding of infectious disease dynamics and the role of data in outbreak response."
  },
  {
    "objectID": "Games/index.html#project-drider",
    "href": "Games/index.html#project-drider",
    "title": "Games",
    "section": "PROJECT DRIDER",
    "text": "PROJECT DRIDER"
  },
  {
    "objectID": "Games/ProjectDrider/index.html",
    "href": "Games/ProjectDrider/index.html",
    "title": "PROJECT DRIDER",
    "section": "",
    "text": "A field ecology simulator that teaches basic principles of ecology and data literacy. Local Network Multiplayer with teacher controls. Learners collect data to test hypotheses based on structured lesson plans. Learners observe the data in-game."
  },
  {
    "objectID": "Games/ProjectDrider/index.html#game-footage",
    "href": "Games/ProjectDrider/index.html#game-footage",
    "title": "PROJECT DRIDER",
    "section": "GAME FOOTAGE",
    "text": "GAME FOOTAGE\nVideo"
  },
  {
    "objectID": "Games/ProjectDrider/index.html#target-audience",
    "href": "Games/ProjectDrider/index.html#target-audience",
    "title": "PROJECT DRIDER",
    "section": "TARGET AUDIENCE",
    "text": "TARGET AUDIENCE\n\nLetting the teacher view student progress (Erik Marsh)\nDrider has a task system where the teacher can assign each student a task to perform. These tasks usually involve catching a certain number of animals to analyze some data (such as the number of ticks on each animal). For a while in the development cycle, players were only aware of their own tasks. In a teaching environment, however, this is far from optimal. The teacher should be aware of each student’s task progress, or else it becomes hard to continue a lesson.\nRecently, I reworked the tasks system to allow for the teacher to see individual student progress. It is not yet implemented into the menu system, but the proof-of-concept is shown in the video. Here, the teacher is able to see task progress for themself and their two students in a centralized, scrollable list. Having this functionality is critical, since a student that is goofing off or is struggling to complete the task may slow down the teacher’s lesson plan. Since the teacher is also an active player of the game, checking in on each student’s progress by walking around the room becomes an interruption, which is why in-game progress monitoring is useful.\nThe logic behind this functionality is quite simple. The existing task system simply “listens” for when players catch animals. If the proper conditions are met (such as the player catching the right animal), task progress increases. This progress is shown on the screen with a progress bar. Usually, the task only listens to the player that is being controlled on the local computer, and ignores the players on the other, remote computers. However, every time the teacher assigns a task, an “extra copy” of the task is put on the teacher’s computer that “listens to” the player that it was assigned to. Thus, the task is aware of that player’s progress, and it can be displayed on screen to the teacher as well.\nVideo"
  },
  {
    "objectID": "Games/ProjectDrider/index.html#the-character",
    "href": "Games/ProjectDrider/index.html#the-character",
    "title": "PROJECT DRIDER",
    "section": "THE CHARACTER",
    "text": "THE CHARACTER\n\nCharacter Creation\n\n\nControls"
  },
  {
    "objectID": "Games/ProjectDrider/index.html#the-environment",
    "href": "Games/ProjectDrider/index.html#the-environment",
    "title": "PROJECT DRIDER",
    "section": "THE ENVIRONMENT",
    "text": "THE ENVIRONMENT\n\nBiomes\n\n\nAnimal Species"
  },
  {
    "objectID": "Games/ProjectDrider/index.html#the-lab-station",
    "href": "Games/ProjectDrider/index.html#the-lab-station",
    "title": "PROJECT DRIDER",
    "section": "THE LAB STATION",
    "text": "THE LAB STATION\n\nData Representation\n\n\nMiniMap"
  },
  {
    "objectID": "Games/ProjectDrider/EDUCATION.html#data-science-literacy",
    "href": "Games/ProjectDrider/EDUCATION.html#data-science-literacy",
    "title": "EDUCATION",
    "section": "DATA SCIENCE LITERACY",
    "text": "DATA SCIENCE LITERACY\n\nVisualizations\n\n\nData Architecture"
  },
  {
    "objectID": "Games/ProjectDrider/DevTeam.html",
    "href": "Games/ProjectDrider/DevTeam.html",
    "title": "Dev Team",
    "section": "",
    "text": "Outbreak Simulator is a component of the education and outreach efforts of the TickBase project. Tickbase is an NSF funded project that seeks to identify critical factors for natural and human driven tick migration and tick-borne disease spread in the western US. The central hypothesis is that climate change will increase the prevalence of tick-borne diseases throughout the western US. To test this hypothesis, the project brings together data scientists, biologists, geospatial modelers, and mathematicians from the University of Idaho, the University of Nevada Reno, Dartmouth University, and New Mexico State University. These researchers collaborate on interdisciplinary projects to study the complex interactions among climate models, tick biology, spatial ecology, socioeconomics, and human behavior.\n\nWhen we develop educational games and simulations for projects like TickBase, we first consider the research from a very broad perspective. In this case, we concluded that the project brings together research from Infectious Disease, Spatial Ecology, and Data Science. We therefore developed our outreach and educational materials to focus on the skills and knowledge inherent to these disciplines. See the Education and Outreach section to learn more about our plans and activities for Outbreak Simulator in K-12, undergraduate, and public health settings."
  },
  {
    "objectID": "Games/ProjectDrider/DevTeam.html#developers",
    "href": "Games/ProjectDrider/DevTeam.html#developers",
    "title": "Dev Team",
    "section": "Developers",
    "text": "Developers\n\nLandon Wright\n\n\nErik Marsh\n\nErik is currently a first-year Master’s student in Computer Science at the University of Nevada, Reno. He received his B.S. in Computer Science and Engineering from the University of Nevada, Reno in 2022. Here, he primarily works on keeping Drider running smoothly, particularly the networking aspects.\n\n\nJoshua Dahl\n\nJoshua Dahl is currently a student at the University of Nevada, Reno. He is pursuing a BS with a major in Computer Science and Engineering and a minor in Mathematics. When he graduates he is planning on pursuing a Ph.D. in Computer Science where he hopes to continue to make contributions to both the fields of computer graphics and programming languages.\nDue to the rapidly evolving nature of the Virtual Reality field, many frameworks for multiuser interaction have become outdated, with few, if any, designed to support mixed virtual and non-virtual interactions. We have developed uMuVR, a framework that lays an extensible and forward-looking foundation for the development of mixed interactions based upon a novel method of ensuring that inputs, visuals, and networking can all communicate without needing to understand the others’ internals. This framework also provides utilities for representing user avatars in a physicalized manner while supporting a range of different input methods. We tested this framework in the development of several applications and show that it can easily be adapted to support application requirements it was not originally designed for.\n\n\nDaniel Enriquez\n\n\nRyan Wagoner\n\n\nLily Mason\n\n\nSam Carlson"
  },
  {
    "objectID": "Games/ProjectDrider/DevTeam.html#research-collaborators",
    "href": "Games/ProjectDrider/DevTeam.html#research-collaborators",
    "title": "Dev Team",
    "section": "Research Collaborators",
    "text": "Research Collaborators"
  },
  {
    "objectID": "Games/ProjectDrider/DevTeam.html#helpful-consultations",
    "href": "Games/ProjectDrider/DevTeam.html#helpful-consultations",
    "title": "Dev Team",
    "section": "Helpful Consultations",
    "text": "Helpful Consultations"
  },
  {
    "objectID": "Games/OutbreakSimulator/Movement.html",
    "href": "Games/OutbreakSimulator/Movement.html",
    "title": "Movement Models",
    "section": "",
    "text": "We have installed two movement models – a diffusion model and a gravitation model (Simini et al., 2021). We use these models for commuting scale movements between adjacent grid cells. For longer (national) movement, we use a data layer of the travel rates between the 150 largest airports in the continental US."
  },
  {
    "objectID": "Games/OutbreakSimulator/Movement.html#population-representation",
    "href": "Games/OutbreakSimulator/Movement.html#population-representation",
    "title": "Movement Models",
    "section": "Population Representation",
    "text": "Population Representation\nThe basic framework of our simulation is essentially a map of population density. The source data for the continental US map is SOURCE. We use a spatial resolution of approximately 11km by 11km, and treat each cell in this grid as an independent population in which mixing is assumed to be homogeneous. Each ‘tick’ of the simulation (each time step, t) the compartment model computes the transition of individuals between states. After this step is completed for every grid cell, we then compute movement of individuals between cells as described below."
  },
  {
    "objectID": "Games/OutbreakSimulator/Movement.html#diffusion-model",
    "href": "Games/OutbreakSimulator/Movement.html#diffusion-model",
    "title": "Movement Models",
    "section": "Diffusion Model",
    "text": "Diffusion Model\nIn this simple movement model, we assume that infected individuals diffuse out from their starting grid cell into adjacent cells (often called the Moore neighborhood). The rate at which this diffusion occurs is modulated by several parameters, depending on the scenario:\n\nBasal diffusion rate. Note that is rate can vary by scenario because the severity of disease can affect mobility of contagious individuals.\nSize of the source population.\nSize of the destination population.\nPresence of major roadways.\nPresence of significant water bodies.\nChange in elevation.\n\nIn addition, certain scenarios allow for user interventions that affect movement:\n\nLockdowns are modeled as a global restriction on mobility, regardless of infection status.\nQuarantine requirements are modeled as restrictions on mobility for infectious individuals."
  },
  {
    "objectID": "Games/OutbreakSimulator/Movement.html#gravitation-model",
    "href": "Games/OutbreakSimulator/Movement.html#gravitation-model",
    "title": "Movement Models",
    "section": "Gravitation Model",
    "text": "Gravitation Model\nDiffusion is a simple system to implement, but isn’t a very good reflection of actual human mobility patterns. This is because we have transportation technology (cars, trains, airplanes) that make it very easy for us to move well past our “Moore Neighborhood” of 11km in a very short amount of time.\nGravitation models of human mobility have been developed that consider the relative sizes of two grid cells anywhere on the map (not just adjacent ones), and modulate exchange of individuals based on the distance between the cells.\nWe used the framework by Simini et al (2012) to parameterize a gravitation model of mobility in our simulation."
  },
  {
    "objectID": "Games/OutbreakSimulator/Movement.html#air-travel",
    "href": "Games/OutbreakSimulator/Movement.html#air-travel",
    "title": "Movement Models",
    "section": "Air Travel",
    "text": "Air Travel\nAnother approach to capturing long distance human mobility is to directly model air travel. To do this we obtained the average flux between the 150 major US airports, and allow proportional travel of infected individuals using this matrix."
  },
  {
    "objectID": "Games/OutbreakSimulator/DiseaseModel.html",
    "href": "Games/OutbreakSimulator/DiseaseModel.html",
    "title": "Disease Model",
    "section": "",
    "text": "Outbreak Simulator uses a compartment model of disease (Weissman et al., 2020) in which the population is divided into categories (Figure 1): Susceptible (S), Exposed (E), Infected (I), Vaccinated (V), Recovered (R), or Deceased (D). The model estimates the rates of exchange between categories over a given time interval (t) using differential equations. When the model parameters are known and key assumptions are met, the differential equations can estimate the epidemic curve of an outbreak. The two most critical assumptions are that the population is homogeneous and well mixed and is fixed in size. Deterministic and stochastic discrete time (Gillespie, 1976) versions of the models offer simpler but computationally performant (deterministic model) and mathematically rigorous but computationally slower (stochastic model) options to use in different educational contexts. We have pre-parameterized scenarios for influenza (multiple strains) and SARS-CoV-2 (multiple variants) and are creating more for additional diseases including Ebola, Measles, Mumps, Rubella, and the common cold. Outbreak Simulator can also be used to model fictional disease systems. For example, many science fiction and horror fiction treatments of zombies are based on fictional viruses (e.g. World War Z, Resident Evil, Walking Dead), and these scenarios could prove to be engaging learning environments for some users(E. T. Lofgren et al., 2016; Smith, 2009).\n\n\n\n\n\n\n\n\n\n\n\n\nOutbreak Simulator parameterizes infectious disease dynamics with an interactive mental model. The beginning of each scenario provides grade appropriate information about the disease. The user is then guided through model parameterization using a drag and drop interface and plain language narrative-based scaffolding (Figure 3). Figure 3 shows a scenario in which the model parameters represent the 1918 influenza strain (Chowell et al., 2007). The interface allows the user to change model parameters using sliders or direct numerical input."
  },
  {
    "objectID": "Games/OutbreakSimulator/DiseaseModel.html#data-visualizations",
    "href": "Games/OutbreakSimulator/DiseaseModel.html#data-visualizations",
    "title": "Disease Model",
    "section": "Data Visualizations",
    "text": "Data Visualizations"
  },
  {
    "objectID": "Games/OutbreakSimulator/DiseaseModel.html#deterministic-and-stochastic-options",
    "href": "Games/OutbreakSimulator/DiseaseModel.html#deterministic-and-stochastic-options",
    "title": "Disease Model",
    "section": "Deterministic and Stochastic Options",
    "text": "Deterministic and Stochastic Options\n\nDeterministic\n\n\nStochastic"
  },
  {
    "objectID": "Games/OutbreakSimulator/DataTextures.html",
    "href": "Games/OutbreakSimulator/DataTextures.html",
    "title": "Data Textures",
    "section": "",
    "text": "We use image files in Outbreak Simulator to store and display spatial data. We call these files textures because although they’re image files, it isn’t pictures that we’re putting into them.\n\nSimply speaking, a texture file can be thought of as a grid of pixels. In a standard colored image, each pixel has a color defined by three channels: red, green, and blue. Each channel holds a value for that pixel which, in the case of color channels, tells us how much of that color is present in the pixel. We usually think of the value of channel as being a floating-point number between 0 and 1.\nIn addition to having three channels per pixel for color, many textures include a fourth channel that defines the opacity of the pixel, or how see-through it is. Some formats even allow for additional channels which aren’t usually visible if trying to view the texture as an image.\n(Image: Color picker in Unity showing the RGBA channel values for a semi-transparent gold color)\nAlthough image files are most often used for storing pictures, they’re also commonly used in games to store other types of information. We can use the channel values of textures to represent any data in any range. Scaling the value from being between 0 to 1 to being between any arbitrary minimum (min) and maximum (max) is pretty straight-forward: (max – min) • value + min\nThe precision of the value stored in each channel is referred to as bit depth. Most images have a bit depth of 8, which means that there are 256 (2^8) possible values stored per channel per pixel. Some formats allow for higher bit depths. Because the level of precision goes up exponentially as the bit depth gets higher (for example, 16bit gives 65536 possible values), it’s not too unrealistic to create textures that contain amazingly precise data"
  },
  {
    "objectID": "Games/OutbreakSimulator/DataTextures.html#textures-for-world-data",
    "href": "Games/OutbreakSimulator/DataTextures.html#textures-for-world-data",
    "title": "Data Textures",
    "section": "Textures for World Data",
    "text": "Textures for World Data\nIn order to make Outbreak Simulator as interesting and realistic as possible, we use many types of spatial data from the real world to run our simulations over. These data include elevation, population, temperature, water coverage, road use trends, and more. We find most of this data in the form of a special kind of image file called a GeoTIFF.\nGeoTIFF is a public domain format that allows georeferencing information, including map projection and coordinate systems, to be embedded within a TIFF file (a non-lossy format that allows for addition channels and bit depths of more than 8 bits per channel). Programs like QGIS can interpret this extra information and allow us to change the scale and reference coordinate system, if necessary, so that we can use it in our simulation.\nThe coordinate reference system that we use is. This is a widely used and easily interpreted projection where the horizontal axis represents longitude between -180° and +180° and the vertical axis represents latitude between -90° and +90° evenly gridded out. WGS 84 is the standard U.S. Department of Defense definition of a global reference system for geospatial information and is the reference system for the Global Positioning System (GPS). It is compatible with the International Terrestrial Reference System (ITRS).\n\n(Image: Road use trends data being converted from Albers USA to WGS84)\nCreating and using procedural textures in unity In addition to using data stored in textures, we also use Unity to create our own data textures in real time as the simulation runs.\nWe can scale our own data for things like, for example, how many and where cases of an outbreak exist into channel values and use Texture2D.SetPixels to create a texture containing this information. The textures we use to display information to the user."
  },
  {
    "objectID": "Games/OutbreakSimulator/index.html",
    "href": "Games/OutbreakSimulator/index.html",
    "title": "OUTBREAK SIMULATOR",
    "section": "",
    "text": "This project is based upon work supported by the National Science Foundation under Grant No. 2019609."
  },
  {
    "objectID": "Games/OutbreakSimulator/index.html#summary",
    "href": "Games/OutbreakSimulator/index.html#summary",
    "title": "OUTBREAK SIMULATOR",
    "section": "Summary",
    "text": "Summary\nOutbreak Simulator is a tool that allows users to simulate the spread of an infectious disease and explore the impact of different interventions. The simulation can be used to promote systems thinking and data science literacy, as users can see how different factors interact to influence the spread of the disease and how data can be used to track, visualize, and understand the outbreak. Outbreak Simulator can be used in educational, research, and public health settings to help people gain a better understanding of infectious disease dynamics and the role of data in outbreak response.\nVideo"
  },
  {
    "objectID": "Games/OutbreakSimulator/index.html#infectious-disease-systems-thinking-and-public-education",
    "href": "Games/OutbreakSimulator/index.html#infectious-disease-systems-thinking-and-public-education",
    "title": "OUTBREAK SIMULATOR",
    "section": "Infectious Disease, Systems Thinking, and Public Education",
    "text": "Infectious Disease, Systems Thinking, and Public Education\nThe SARS-CoV-2 pandemic highlighted that many people were not sufficiently equipped to understand the complex nature of infectious diseases and the uncertainties involved in managing them. This lack of public understanding made people more vulnerable to misinformation and disinformation, resulting in the formation of misconceptions about infectious diseases and public health. Pandemic mitigation strategies and compliance with public health guidance suffered as a result. Equipping the public to better understand infectious diseases requires integration of multiple complex systems, including pathogen biology, the human immune system, and systems of human behavior that are influenced by economic, social, and environmental factors. Tools that improve domain knowledge, systems thinking skills, scientific reasoning, and data literacy (e.g., simulation, data visualization) could help better prepare the public to grapple with the complexity of infectious disease dynamics.\nComputer simulations with interactive visualizations of dynamic phenomenon are a potentially useful vehicle for presenting infectious diseases as a complex system. This promotes systems thinking, which is the ability to see connections and relationships between different factors and can help people understand how small changes in one area can have large effects on the overall system. Adopting a systems thinking framework can demonstrate dynamic relationships between components of a larger whole (Von Bertalanffy & Sutherland, 1974), multi-level heterogeneity of agents, nonlinear dynamics, stochasticity, and emergence of new patterns (Eckhardt et al., 2020; J. H. Miller & Page, 2009; Pearce & Merletti, 2006; Roux, 2011). Systems thinking is essential in understanding the complex dynamics of infectious disease and can help to promote better decision-making and problem-solving. To meet this need, we created Outbreak Simulator (Table 1), a game-like interactive simulation that uses engaging grade-appropriate scenarios of infectious disease to improve domain knowledge (viruses and infectious diseases), systems thinking (complexity, component relationships, emergent behaviors), and data literacy (interpretation of visualizations and argumentation from evidence)."
  },
  {
    "objectID": "Games/OutbreakSimulator/index.html#simulation-description",
    "href": "Games/OutbreakSimulator/index.html#simulation-description",
    "title": "OUTBREAK SIMULATOR",
    "section": "Simulation Description",
    "text": "Simulation Description\n\nMathematical Model of Infectious Disease\nOutbreak Simulator uses a compartment model of disease (Weissman et al., 2020) in which the population is divided into categories (Figure 1): Susceptible (S), Exposed (E), Infected (I), Vaccinated (V), Recovered (R), or Deceased (D). The model estimates the rates of exchange between categories over a given time interval (t) using differential equations. When the model parameters are known and key assumptions are met, the differential equations can estimate the epidemic curve of an outbreak. The two most critical assumptions are that the population is homogeneous and well mixed and is fixed in size. Deterministic and stochastic discrete time (Gillespie, 1976) versions of the models offer simpler but computationally performant (deterministic model) and mathematically rigorous but computationally slower (stochastic model) options to use in different educational contexts. We have pre-parameterized scenarios for influenza (multiple strains) and SARS-CoV-2 (multiple variants) and are creating more for additional diseases including Ebola, Measles, Mumps, Rubella, and the common cold. Outbreak Simulator can also be used to model fictional disease systems. For example, many science fiction and horror fiction treatments of zombies are based on fictional viruses (e.g. World War Z, Resident Evil, Walking Dead), and these scenarios could prove to be engaging learning environments for some users(E. T. Lofgren et al., 2016; Smith, 2009).\n\n\n\n\n\n\n\n\n\n\n\n\nGeospatial Representation:\nThe compartment model described above assumes a homogeneous and well mixed population - an assumption that is clearly violated when we consider the geographic scope of many infectious diseases. For example, consider the population of the continental United States. There are many factors within the US population that affect the mixing of individuals, including transportation patterns at the local and national scale. While modern transportation increases the mixing of the US population compared to previous pandemics (such as the 1918 influenza outbreak), we have seen that social distancing and travel restrictions can profoundly affect transmission dynamics at the national scale. There can also be considerable geospatial variation in the parameters of the model itself. For example, contact rate (number of individuals that an infectious individual contacts per time interval t) is likely to vary between urban and rural environments. Even seasonal outbreaks of influenza and the common cold can vary depending on spatial and temporal variation of temperature and host health (E. Lofgren et al., 2007). These spatial effects on the modeling of disease can be important in showing learners how outbreaks might affect their region, and how spatial heterogeneity adds complexity to model predictions. To represent the spatial effects of infectious disease dynamics, our simulation models the population as a gridded set of subpopulations. Outbreak Simulator incorporates also uses spatial data layers (Table 1) to modify the parameters of the disease and movement models for each grid cell. We have installed two movement models – a diffusion model and a gravitation model (Simini et al., 2021). We use these models for commuting scale movements between adjacent grid cells. For longer (national) movement, we use a data layer of the travel rates between the 150 largest airports in the continental US.\n\n\nEmbedded Data Visualizations\nOutbreak Simulator uses interactive visualizations intended to help users understand the dynamics of disease ecology, practice scientific inquiry skills, and build data literacy. Figure 2 is a screen shot of Outbreak Simulator, annotated with letters which indicate system components and different visualizations. INFECTED, EXPOSED, and DECEASED individuals are indicated in area (I) on the map by color. The interactive map (A) can be panned, zoomed, and displayed with different data (satellite with population data overlay shown). Elapsed time, speed controls, help, and settings are accessed with a collapsible panel (B). Display settings such as color and visibility for each model compartment on the map can also be customized (C). Other features include a population health bar (D), buttons for initiating an outbreak, an Interventions menu (E), and an Event Log that describes simulation milestones such as initial outbreak location and timestamps of infection events (F). The intervention option allows the user to test how choices related to public health guidance (such as air travel restrictions, local lockdowns, masking, and vaccination) might impact outbreak dynamics.\n\nData visualizations in Outbreak Simulator are interactive, dynamic, and inter-related. For example, the spatial dynamics of the outbreak can be observed by watching the expansion of red (infected) color across the map (Fig 1 I), by scrolling through the event log (Fig 1 F), or by viewing the epidemic curve of a selected state (Fig 1 G). The dynamic graphs (Fig 1 G and H) are interactive in that each model compartment can be toggled and the scale dynamically adjusted. Hovering over the graph shows the exact values for all model component at the hovered time point (Fig 1 G).\nOutbreak Simulator parameterizes infectious disease dynamics with an interactive mental model. The beginning of each scenario provides grade appropriate information about the disease. The user is then guided through model parameterization using a drag and drop interface and plain language narrative-based scaffolding (Figure 3). Figure 3 shows a scenario in which the model parameters represent the 1918 influenza strain (Chowell et al., 2007). The interface allows the user to change model parameters using sliders or direct numerical input."
  },
  {
    "objectID": "Games/OutbreakSimulator/Education.html#k-12",
    "href": "Games/OutbreakSimulator/Education.html#k-12",
    "title": "Education and Outreach",
    "section": "K-12",
    "text": "K-12\nWhen we consider Outbreak Simulator in a K-12 learning context, we usually frame our activities in the context of the Next Generation Science Standards (NGSS). The NGSS consider three distinct dimensions of learning science - DISCIPLINARY CORE IDEAS (what students know), CROSSCUTTING CONCEPTS (how students think), and SCIENCE AND ENGINEERING PRACTICES (what students do). The figure below is a visualization of how Outbreak Simulator aligns with some of the NGSS components in each of these dimensions.\n\nWe are particularly interested in developing scenarios, lab modules, and activities that help middle and high school students build systems thinking, scientific reasoning, and data literacy skills. We welcome suggestions and collaboration inquiries from any interested researchers and educators.\nEmail Barrie Robison"
  },
  {
    "objectID": "Games/OutbreakSimulator/Education.html#undergraduate",
    "href": "Games/OutbreakSimulator/Education.html#undergraduate",
    "title": "Education and Outreach",
    "section": "Undergraduate",
    "text": "Undergraduate"
  },
  {
    "objectID": "Games/OutbreakSimulator/Education.html#public-health",
    "href": "Games/OutbreakSimulator/Education.html#public-health",
    "title": "Education and Outreach",
    "section": "Public Health",
    "text": "Public Health"
  },
  {
    "objectID": "Games/OutbreakSimulator/Education.html#other-outreach-contexts",
    "href": "Games/OutbreakSimulator/Education.html#other-outreach-contexts",
    "title": "Education and Outreach",
    "section": "Other Outreach Contexts",
    "text": "Other Outreach Contexts"
  },
  {
    "objectID": "Games/OutbreakSimulator/DevTeam.html",
    "href": "Games/OutbreakSimulator/DevTeam.html",
    "title": "Dev Team",
    "section": "",
    "text": "Outbreak Simulator is a component of the education and outreach efforts of the TickBase project. Tickbase is an NSF funded project that seeks to identify critical factors for natural and human driven tick migration and tick-borne disease spread in the western US. The central hypothesis is that climate change will increase the prevalence of tick-borne diseases throughout the western US. To test this hypothesis, the project brings together data scientists, biologists, geospatial modelers, and mathematicians from the University of Idaho, the University of Nevada Reno, Dartmouth University, and New Mexico State University. These researchers collaborate on interdisciplinary projects to study the complex interactions among climate models, tick biology, spatial ecology, socioeconomics, and human behavior.\n\nWhen we develop educational games and simulations for projects like TickBase, we first consider the research from a very broad perspective. In this case, we concluded that the project brings together research from Infectious Disease, Spatial Ecology, and Data Science. We therefore developed our outreach and educational materials to focus on the skills and knowledge inherent to these disciplines. See the Education and Outreach section to learn more about our plans and activities for Outbreak Simulator in K-12, undergraduate, and public health settings."
  },
  {
    "objectID": "Games/OutbreakSimulator/DevTeam.html#developers",
    "href": "Games/OutbreakSimulator/DevTeam.html#developers",
    "title": "Dev Team",
    "section": "Developers",
    "text": "Developers"
  },
  {
    "objectID": "Games/OutbreakSimulator/DevTeam.html#research-collaborators",
    "href": "Games/OutbreakSimulator/DevTeam.html#research-collaborators",
    "title": "Dev Team",
    "section": "Research Collaborators",
    "text": "Research Collaborators"
  },
  {
    "objectID": "Games/OutbreakSimulator/DevTeam.html#helpful-consultations",
    "href": "Games/OutbreakSimulator/DevTeam.html#helpful-consultations",
    "title": "Dev Team",
    "section": "Helpful Consultations",
    "text": "Helpful Consultations"
  },
  {
    "objectID": "Games/OutbreakSimulator/Maps.html",
    "href": "Games/OutbreakSimulator/Maps.html",
    "title": "Maps and Data Layers",
    "section": "",
    "text": "The compartment model described here assumes a homogeneous and well mixed population - an assumption that is clearly violated when we consider the geographic scope of many infectious diseases. For example, consider the population of the continental United States. There are many factors within the US population that affect the mixing of individuals, especially transportation patterns at the local and national scale. While modern transportation increases the mixing of the US population compared to previous pandemics (such as the 1918 influenza outbreak), interventions such as social distancing and travel restrictions can profoundly affect transmission dynamics at the national scale.\nThere can also be considerable geospatial variation in the parameters of the model itself. For example, contact rate (number of individuals that an infectious individual contacts per time interval t) is likely to vary between urban and rural environments. Even seasonal outbreaks of influenza and the common cold can vary depending on spatial and temporal variation of temperature and host health (E. Lofgren et al., 2007). These spatial effects on the modeling of disease can be important in showing learners how outbreaks might affect their region, and how spatial heterogeneity adds complexity to model predictions.\nTo represent the spatial effects of infectious disease dynamics, our simulation models the population as a gridded set of subpopulations. Outbreak Simulator also uses spatial data layers to modify the parameters of the disease and movement models for each grid cell."
  },
  {
    "objectID": "Games/OutbreakSimulator/Maps.html#data-layers",
    "href": "Games/OutbreakSimulator/Maps.html#data-layers",
    "title": "Maps and Data Layers",
    "section": "Data Layers",
    "text": "Data Layers\nOutbreak Simulator is designed to use spatial data in GEOTIFF format.\n\nPopulation\n\n\nElevation\n\n\nWater\n\n\nRoadways\n\n\nAir Travel\n\n\nVaccine Hesitancy"
  }
]